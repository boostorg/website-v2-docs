////
Copyright (c) 2024 The C++ Alliance, Inc. (https://cppalliance.org)

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Official repository: https://github.com/boostorg/website-v2-docs
////
= Frequently Asked Questions
:navtitle: FAQ

This section contains answers to the common questions that new developers to Boost often have.

== Compatibility

. *Can I use Boost with my existing pass:[C++] project?*

+
Yes, Boost is designed to work with your existing pass:[C++] code. You can add Boost libraries to any project that uses a compatible pass:[C++] compiler.

. *Can I use Boost libraries with the new pass:[C++] standards?*

+
Yes, Boost libraries are designed to work with modern pass:[C++] standards including pass:[C++11], pass:[C++14], pass:[C++17], pass:[C++20], and pass:[C++23].

. *What flavors of Linux are supported by the Boost libraries?*
+
Boost libraries are generally compatible with most Linux distributions, provided that the distribution has an up-to-date pass:[C++] compiler. This includes:
+
* Ubuntu
* Fedora
* Debian
* CentOS
* Red Hat Enterprise Linux
* Arch Linux
* openSUSE
* Slackware
* Gentoo
* macOS

. *How can I be sure that a library I want to use is compatible with my OS?*
+
While Boost strives to ensure compatibility with a wide range of compilers and systems, not every library may work perfectly with every system or compiler due to the inherent complexities of software. The most reliable source of information is the specific Boost library's documentation.

== Debugging

. *What support does Boost provide for debugging and testing?*
+
Boost provides boost:test[] for unit testing, which can be an integral part of the debugging process. It also provides the boost:stacktrace[] library that can be used to produce useful debug information during a crash or from a running application.

. *How do I enable assertions in Boost?*
+
Boost uses its own set of assertion macros. By default, `BOOST_ASSERT` is enabled, but if it fails, it only calls `abort()`. If you define `BOOST_ENABLE_ASSERT_HANDLER` before including any Boost header, then you need to supply `boost::assertion_failed(msg, code, file, line)` and `boost::assertion_failed_msg(msg, code, file, line)` functions to handle failed assertions.

. *How can I get a stack trace when my program crashes?*
+
You can use the boost:stacktrace[] library to obtain a stack trace in your application. You can capture and print stack traces in your catch blocks, in signal handlers, or anywhere in your program where you need to trace the execution path.

. *Can I use Boost with a debugger like GDB or Visual Studio?*
+
Yes, Boost libraries can be used with common debuggers like https://sourceware.org/gdb/[GDB] or https://visualstudio.microsoft.com/downloads/[Visual Studio]. You can set breakpoints in your code, inspect variables, and execute code step by step. Boost doesn't interfere with these debugging tools.

. *Are there any debugging tools specifically provided by Boost?*
+
Boost doesn't provide a debugger itself. The libraries tend to make heavy use of assertions to catch programming errors, and they often provide clear and detailed error messages when something goes wrong.

. *What are best practices when using Boost Asserts?*
+
Boost provides the assertion `boost::assert`. Best practices when using this are:

+
[disc]
* _Use Assertions for Debugging and Development_: Boost assertions should primarily be used during the debugging and development phase of your application. Assertions are designed to catch programming errors, not user errors.

* _Assert Conditions That Should Never Occur_: You should only assert conditions that you believe can never occur during normal operation of your application. If there's a chance that a condition may occur, handle it as an exception or error rather than asserting.

* _Provide Meaningful Assert Messages_: Boost assertions allow you to provide a message alongside your assertion. Use this feature to provide meaningful context about why an assertion failed.

* _Consider Performance Impact_: Boost assertions can slow down your application. In performance-critical code, consider disabling them in the production version of your application.

. *What is the recommended approach to logging, using `boost::log`?*
+
[disc]
* _Use Severity Levels_: boost:log[] supports severity levels, which you can use to categorize and filter your log messages. This can help you control the amount of log output and focus on what's important.

* _Provide Context_: boost:log[] allows you to attach arbitrary data to your log messages, such as thread IDs, timestamps, or file and line information. Use this feature to provide context that can help you understand the state of your application when the log message was generated.

* _Use Asynchronous Logging_: If logging performance is a concern, consider using the asynchronous logging feature. This allows your application to continue executing while log messages are processed in a separate thread.

* _Format Your Log Output_: boost:log[] supports customizable log formatting. Use this feature to ensure that your log output is easy to read and contains all the information you need.

* _Handle Log Rotation_: If your application produces a lot of log output, consider setting up log rotation, which is supported. This ensures that your log files don't grow indefinitely.

[[isocommitteemeetings]]
== ISO C++ Committee Meetings

. *Who can attend ISO C++ Committee meetings?*
+
Members of https://www.incits.org/committees/pl22.16[PL22.16] (the INCITS/ANSI committee) or of https://www.open-std.org/jtc1/sc22/wg21/[JTC1/SC22/WG21 - The C++ Standards Committee - ISOCPP] member country committee (the "national body" in ISO-speak), can attend the meetings. You can also attend as a guest, or join in remotely through email. For details and contact information refer to https://isocpp.org/std/meetings-and-participation/[Meetings and Participation].
+
https://www.incits.org/[INCITS] has broadened PL22.16 membership requirements so anyone can join, regardless of nationality or employer, though there is a fee. Refer to https://www.incits.org/participation/apply-for-membership[Apply for Membership].
+
It is recommended that any non-member who would like to attend should check in with the https://www.incits.org/committees/pl22.16[PL22.16] chair or head of their national delegation. Boosters who are active on the committee can help smooth the way, so consider contacting the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost developers' mailing list] providing details of your interests.

. *When and where are the next meetings?*
+
There are three meetings a year. Two are usually in North America, and one is usually outside North America. See https://isocpp.org/std/meetings-and-participation/upcoming-meetings[Upcoming Meetings]. Detailed information about a particular meeting, including hotel information, is usually provided in a paper appearing in one of mailings for the prior meeting. If there isn't a link to it on the Meetings web page, you will have to go to the committee's https://www.open-std.org/jtc1/sc22/wg21/docs/papers/[C++ Standards Committee Papers] page and search a bit.

. *Is there a fee for attending meetings?*
+
No, but there can be a lot of incidental expenses like travel, lodging, and meals.

. *What is the schedule?*
+
The meetings typically start at 9:00AM on Monday, and 8:30AM other days. It is best to arrive a half-hour early to grab a good seat, some coffee, tea, or donuts, and to say hello to people.
+
Until the next standard ships most meetings are running through Saturday, although some end on Friday. The last day, the meeting is generally over much earlier than on other days. Because the last day's formal meeting is for formal votes only, it is primarily of interest only to actual committee members.
+
Sometimes there are evening technical sessions; the details aren't usually available until the Monday morning meeting. There may be a reception one evening, and, yes, significant others are invited. Again, details usually become available Monday morning.

. *What actually happens at the meetings?*
+
Monday morning an hour or two is spent in full committee on admin trivia, and then the committee breaks up into working groups (Core, Library, and Enhancements). The full committee also gets together later in the week to hear working group progress reports.
+
The working groups are where most technical activities take place. Each active issue that appears on an _issues list_ is discussed, as are papers from the mailing. Most issues are non-controversial and disposed of in a few minutes. Technical discussions are often led by long-term committee members, often referring to past decisions or longstanding working group practice. Sometimes a controversy erupts. It takes first-time attendees awhile to understand the discussions and how decisions are actually made. The working group chairperson moderates.
+
Sometimes straw polls are taken. In a straw poll anyone attending can vote, in contrast to the formal votes taken by the full committee, where only voting members can vote.
+
Lunch break is an hour and a half. Informal subgroups often lunch together; a lot of technical problems are discussed or actually solved at lunch, or later at dinner. In many ways these discussions involving only a few people are the most interesting. Sometimes during the regular meetings, a working group chair will break off a sub-group to tackle a difficult problem.

. *Do I have to stay at the venue hotel?*
+
No, and committee members on tight budgets often stay at other, cheaper, hotels. The venue hotels are usually chosen because they have large meeting rooms available, and thus tend to be pricey. The advantage of staying at the venue hotel is that it is then easier to participate in the off-line discussions, which can be at least as interesting as what actually happens in the scheduled meetings.

. *What do people wear at meetings?*
+
Programmer casual. No neckties to be seen.

. *What should I bring to a meeting?*
+
It is almost essential to have a laptop computer. There is a meeting wiki and there is internet connectivity. Wireless connectivity has become the norm.

. *What should I do to prepare for a meeting?*
+
It is helpful to have downloaded the mailing or individual papers for the meeting, and to have read any papers you are interested in. Familiarize yourself with the issues lists. Decide which of the working groups you want to attend.

. *What is a "Paper"?*
+
An electronic document containing issues, proposals, or anything else the committee is interested in. Very little gets discussed at a meeting, much less acted upon, unless it is presented in a paper. Papers are available to anyone. Papers don't just appear randomly; they become available four (lately six) times a year, before and after each meeting. Committee members often refer to a paper by saying what mailing it was in, for example: "See the pre-Redmond mailing."

. *What is a "Mailing"?*
+
A mailing is the set of papers prepared before and after each meeting, or between meetings. It is physically just a .zip or .gz archive of all the papers for a meeting. Although the mailing's archive file itself is only available to committee members and technical experts, the contents (except copies of the standard) are available to all as individual papers. The ways of ISO are inscrutable.

. *What is a "Reflector"?*
+
The committee's mailing lists are called "reflectors". There are a number of them; "all", "core", "lib", and "ext" are the main ones. As a courtesy, Boost technical experts can be added to committee reflectors at the request of a committee member.

== Libraries

. *What are smart pointers in Boost?*
+
Smart pointers are a feature of pass:[C++] that Boost provides in its boost:smart_ptr[] library. They are objects that manage the lifetime of other objects, automatically deleting the managed object when it is no longer needed. See the <<Smart Pointers>> section.

. *Does Boost provide a testing framework?*
+
Yes, boost:test[] is the unit testing framework provided by Boost. It includes tools for creating test cases, test suites, and for handling expected and unexpected exceptions. Refer to xref:testing-debugging.adoc[].

. *What is Boost.Asio?*
+
boost:asio[] is a library that provides support for _asynchronous_ input/output (I/O), a programming concept that allows operations to be executed without blocking the execution of the rest of the program.

. *What is Boost.MP11?*
+
boost:mp11[] (MetaProgramming Library for pass:[C++]11) is a Boost library designed to bring powerful metaprogramming capabilities to pass:[C++] programs. It includes a variety of templates that can be used to perform compile-time computations and manipulations. Refer to <<Metaprogramming>>.

. *Does Boost provide a library for threading?*
+
Yes, boost:thread[] provides a pass:[C++] interface for creating and managing threads, as well as primitives for synchronization and inter-thread communication. In addition, boost:atomic[] provides atomic operations and memory ordering primitives for working with shared data in multi-threaded environments. boost:lockfree[] provides lock-free data structures and algorithms for concurrent programming, allowing multiple threads to access shared data concurrently without explicit synchronization using locks or mutexes. For a lighter approach to multi-threading, consider boost:fiber[]. Fibers offer a high-level threading abstraction that allows developers to write asynchronous, non-blocking code with minimal overhead compared to traditional kernel threads. 

. *What is the Boost Spirit library?*
+
boost:spirit[] is a library for building recursive-descent parsers directly in pass:[C++]. It uses template metaprogramming techniques to generate parsing code at compile time. Refer to <<Metaprogramming>>.

. *I like algorithms, can you pique my interest with some Boost libraries that support complex algorithms?* 
+
Boost libraries offer a wide range of algorithmic and data structure support. Here are five libraries that you might find interesting:

+
* boost:graph[]: This library provides a way to represent and manipulate graphs. It includes algorithms for breadth-first search, depth-first search, https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm[Dijkstra's shortest paths], https://en.wikipedia.org/wiki/Kruskal%27s_algorithm[Kruskal's minimum spanning tree], and much more.

* boost:geometry[]: This library includes algorithms and data structures for working with geometric objects. It includes support for spatial indexing, geometric algorithms (like area calculation, distance calculation, intersections, etc.), and data structures to represent points, polygons, and other geometric objects.

* boost:multiprecision[]: If you need to perform computations with large or precise numbers, this library can help. It provides classes for arbitrary precision arithmetic, which can be much larger or more precise than the built-in types.

* boost:compute[]: This library provides a pass:[C++] interface to multi-core CPU and GPGPU (General Purpose GPU) computing platforms based on OpenCL. It includes algorithms for sorting, searching, and other operations, as well as containers like vectors and deques.

* boost:spirit[]: If you're interested in parsing or generating text, this library includes powerful tools based on formal grammar rules. It's great for building compilers, interpreters, or other tools that need to understand complex text formats.

. *I am tasked with building a real-time simulation of vehicles in pass:[C++]. What Boost libraries might give me the performance I need for real-time work, and support a simulation?*
+
Refer to xref:task-simulation.adoc[].

== Licensing 

. *What is the license for Boost libraries?*
+
The Boost libraries are licensed under the Boost Software License, a permissive free software license that allows you to use, modify, and distribute the software under minimal restrictions. Refer to xref:bsl.adoc[].

== Metaprogramming

. *What is metaprogramming in the context of Boost pass:[C++]?*
+
Metaprogramming is a technique of programming that involves generating and manipulating programs. In the context of Boost and pass:[C++], metaprogramming often refers to _template metaprogramming_, which uses templates to perform computations at compile-time.

. *What is Boost.MP11?*
+
boost:mp11[] is a Boost library designed for metaprogramming using pass:[C++]11. It provides a set of templates and types for compile-time computations and manipulations, effectively extending the pass:[C++] template mechanism.

. *What can I achieve with Boost.MP11?*
+
With boost:mp11[], you can perform computations and logic at compile-time, thus reducing runtime overhead. For example, you can manipulate types, perform iterations, make decisions, and do other computations during the compilation phase.

. *What is a `typelist` and how can I use it with Boost.MP11?*
+
A `typelist` is a compile-time container of types. It's a fundamental concept in pass:[C++] template metaprogramming where operations are done at compile time rather than runtime, and types are manipulated in the same way that values are manipulated in regular programming.
+
In the context of the boost:mp11[] library, a `typelist` is a template class that takes a variadic list of type parameters. Here's an example:
+
[source,cpp]
----
#include <boost/mp11/list.hpp>

using my_typelist = boost::mp11::mp_list<int, float, double>;
----
+
In this example, `my_typelist` is a `typelist` containing the types `int`, `float`, and `double`. Once you have a `typelist`, you can manipulate it using the metaprogramming functions provided by the library. For example:
+
[source,cpp]
----
#include <boost/mp11/list.hpp>
#include <boost/mp11/algorithm.hpp>

using my_typelist = boost::mp11::mp_list<int, float, double>;

// Get the number of types in the list
constexpr std::size_t size = boost::mp11::mp_size<my_typelist>::value;

// Check if a type is in the list
constexpr bool contains_double = boost::mp11::mp_contains<my_typelist, double>::value;

// Add a type to the list
using extended_typelist = boost::mp11::mp_push_back<my_typelist, char>;

// Get the second type in the list
using second_type = boost::mp11::mp_at_c<my_typelist, 1>;
----
+
In these examples, `mp_size` is used to get the number of types in the list, `mp_contains` checks if a type is in the list, `mp_push_back` adds a type to the list, and `mp_at_c` retrieves a type at a specific index in the list. All these operations are done at compile time.

. *What are some limitations or challenges of metaprogramming with Boost.MP11?*
+
Metaprogramming with boost:mp11[] can lead to complex and difficult-to-understand code, especially for programmers unfamiliar with the technique. Compile errors can be particularly cryptic due to the way templates are processed. Additionally, heavy use of templates can lead to longer compile times.
+
Other challenges include lack of runtime flexibility, as decisions are made at compile time. And perhaps issues with portability can occur (say, between compilers) as metaprogramming pushes the boundaries of a computer language to its limits.

NOTE: boost:mp11[] supersedes the earlier boost:mpl[] and boost:preprocessor[] libraries.

== Modular Boost

. *What is meant by "Modular Boost"?*
+
Technically, Modular Boost consists of the Boost super-project and separate projects for each individual library in Boost. In terms of Git, the Boost super-project treats the individual libraries as submodules. Currently (early 2024) when the Boost libraries are downloaded and installed, the build organization does _not_ match the modular arrangement of the Git super-project. This is largely a legacy issue, and there are advantages to the build layout matching the super-project layout. This concept, and the effort behind it, is known as "Modular Boost".
+
Refer to the xref:contributor-guide:ROOT:superproject/overview.adoc[] topic (in the xref:contributor-guide:ROOT:index.adoc[]) for a full description of the super-project.

. *Will a Modular Boost affect the thrice-yearly Boost Release?*
+
No. The collection of libraries is still a single release, and there are no plans to change the release cadence.

. *Will this require that the current Boost source structure is changed?*
+
Yes. Unfortunately there is one restriction that adhering to a modular Boost requires - there can be no sub-libraries. That is, we can't support having libraries in the `root/libs/<group name>/<library>` format. All libraries must be single libraries under the `root/libs` directory. There's only a handful of libraries that currently do not conform to this already (notably the `root/libs/numeric/<name>` group of libraries).

. *Why do we want a Modular Boost?*
+
It's easier on everyone if we adopt a flat hierarchy. The user will experience a consistent process no matter which libraries they want to use. Similarly for contributors, the creation process will be consistent. Also, tools can be written that can parse and analyze libraries without an awkward range of exceptions. This includes tools written by Boost contributors. For example, the tools that are used to determine library dependencies. And any tool that a user might want to write for their own, or shared, use.

+
Other advantages of a modular format include:
+
* Users of Boost can now choose to include only the specific modules they need for their project, rather than downloading and building the entire Boost framework. This can significantly reduce the size of the codebase and dependencies in a project, leading to faster compilation times and reduced resource usage.
+
* Individual modules can be updated and released on their own schedule, independent of the rest of the libraries. This allows for quicker updates and bug fixes to individual libraries without waiting for a full release.
+
* The structure aligns well with package managers like https://conan.io/[Conan], https://vcpkg.io/en/[vcpkg], or https://bazel.build/about[Bazel], making it easier to manage Boost libraries within larger projects. Users can specify exactly which Boost libraries they need, and the package manager handles the inclusion and versioning.

. *Will the proposed changes be backwards-compatible from the user's perspective. In particular, the public header inclusion paths will still be <boost/numeric/<name>.hpp> rather than, say, <boost/numeric-conversion/<name>.hpp>, correct?*
+
Correct - backwards-compatibility should be maintained.

. *When will Modular Boost be available to users?*
+
An exact timeline requires issues to be resolved, though later in 2024 is the current plan-of-record.

== Other Languages

. *Have developers written applications in languages such as Python that have successfully used the Boost libraries?*
+
Yes, developers have successfully used Boost libraries in applications written in languages other than pass:[C++] by leveraging language interoperability features and creating bindings or wrappers.
+
The most notable example is the use of boost:python[], a library specifically designed to enable seamless interoperability between pass:[C++] and Python. boost:python[] allows developers to expose pass:[C++] classes, functions, and objects to Python, enabling the use of the libraries from Python code. This has been used extensively in scientific computing, game development, and other fields where the performance of pass:[C++] is combined with the ease of Python.
+
Here is an example, wrapping a pass:[C++] class for use with boost:python[] and including exception handling:
+
[source,cpp]
----
// my_class.cpp
#include <boost/python.hpp>
#include <iostream>
#include <stdexcept>

class MyClass {
public:
    void hello() {
        std::cout << "Hello from C++!" << std::endl;
    }

    int add(int a, int b) {
        return a + b;
    }

    void throw_exception() {
        throw std::runtime_error("An error occurred in C++ code");
    }
};

// Function to translate C++ exceptions to Python exceptions
void translate_runtime_error(const std::runtime_error& e) {
    PyErr_SetString(PyExc_RuntimeError, e.what());
}

BOOST_PYTHON_MODULE(my_module) {
    using namespace boost::python;
    // Register the exception translator
    register_exception_translator<std::runtime_error>(translate_runtime_error);

    class_<MyClass>("MyClass")
        .def("hello", &MyClass::hello)
        .def("add", &MyClass::add)
        .def("throw_exception", &MyClass::throw_exception);
}

----
+
You need to compile this pass:[C++] code into a shared library that Python can load. Here's an example command for compiling using g++ on Linux. Make sure to adjust the Python include path and boost:python[] library name according to your system's configuration:
+
----
g++ -shared -fPIC -I/usr/include/python3.8 -lboost_python38 -o my_module.so my_class.cpp
----
+
Next, write the Python code that will use the wrapped class:
+
[source,python]
----
# test_my_module.py
import my_module

# Create an instance of MyClass
my_class_instance = my_module.MyClass()

# Call the hello method
my_class_instance.hello()

# Call the add method
result = my_class_instance.add(3, 4)
print(f"The result of adding 3 and 4 is: {result}")

# Call the throw_exception method and handle the exception
try:
    my_class_instance.throw_exception()
except RuntimeError as e:
    print(f"Caught an exception: {e}")

----
+
Ensure that the shared library (`my_module.so`) is in the same directory as your Python script or in a directory that's included in the Python module search path. Then run the script:
+
----
python3 test_my_module.py
----
+
When you run the Python script, you should see the following output:
+
----
Hello from C++!
The result of adding 3 and 4 is: 7
Caught an exception: An error occurred in C++ code
----
+
Note:: By registering an exception translator, you can ensure that pass:[C++] exceptions are correctly translated into Python exceptions, making your pass:[C++] library more robust and easier to use from Python.

. *What real world applications have combined Python with the Boost libraries?*
+
Here are some examples:
+
* https://www.blender.org/[Blender] is a widely-used open-source 3D creation suite. It supports the entirety of the 3D pipeline, including modeling, rigging, animation, simulation, rendering, compositing, and motion tracking. Blender uses Boost libraries for various purposes, including memory management, string manipulation, and other utility functions. Blender's Python API, which allows users to script and automate tasks, integrates with pass:[C++] code using boost:python[].
+
* https://pytorch.org/[PyTorch] is an open-source machine learning library based on the Torch library. It is used for applications such as natural language processing and computer vision. PyTorch uses several Boost libraries to handle low-level operations efficiently. boost:python[] is used to create bindings between pass:[C++] and Python, allowing PyTorch to provide a seamless interface for Python developers.
+
* https://opencv.org/[OpenCV] (Open Source Computer Vision Library) is an open-source computer vision and machine learning software library. OpenCV's Python bindings use boost:python[] to interface between the pass:[C++] core and Python. This allows Python developers to use OpenCV's powerful pass:[C++] functions with Python syntax.
+
* https://docs.enthought.com/canopy/2.1/index.html[Enthought Canopy] is a comprehensive Python analysis environment and distribution for scientific and analytic computing. It includes a Python distribution, an integrated development environment (IDE), and many additional tools and libraries.

. *Are there some solid examples of real world applications that have combined C# with the Boost libraries?*
+
Here are some great examples:
+ 
* In the world of game development, several projects use pass:[C++] for performance-critical components and C# for scripting and higher-level logic. The Boost libraries are often used in the pass:[C++] components, in particular to leverage their algorithms, and data structures. https://unity.com/[Unity] allows the use of native plugins written in pass[C++]. These plugins can use Boost libraries for various functionalities, such as pathfinding algorithms or custom data structures, and then be called from C# scripts within Unity.
+
* Financial applications often require high performance and reliability. They may use pass:[C++] for core processing and Boost libraries for tasks like date-time calculations, serialization, and multithreading. C# is used for GUI and integration with other enterprise systems. Trading platforms and risk management systems sometimes use Boost libraries for backend processing and interoperate with C# components for the user interface and data reporting.
+
* Scientific computing applications that need high-performance computation often use pass:[C++] for core algorithms. C# is great for visualization, user interaction, and orchestration. Computational chemistry and physics applications sometimes use Boost for numerical computations and data handling, while C# provides the tools for managing simulations and visualizing results.

. *Can I see some sample code of how to wrap Boost functions to be available for use in a C# app?*
+
The following code shows how to create a wrapper for a pass:[C++] class that uses Boost, and then calls this from a C# application. The handling of return values and exceptions are shown too:
+
[source,cpp]
----
// my_class.cpp
#include <boost/algorithm/string.hpp>
#include <iostream>
#include <stdexcept>
#include <string>

class MyClass {
public:
    std::string to_upper(const std::string& input) {
        if (input.empty()) {
            throw std::runtime_error("Input string is empty");
        }
        return boost::to_upper_copy(input);
    }
};
----
+
Next, create a wrapper to expose the class to .NET:
+
[source,cpp]
----
// MyClassWrapper.cpp
#include "my_class.cpp"
#include <string>

public ref class MyClassWrapper {
private:
    MyClass* instance;

public:
    MyClassWrapper() {
        instance = new MyClass();
    }

    ~MyClassWrapper() {
        this->!MyClassWrapper();
    }

    !MyClassWrapper() {
        delete instance;
    }

    System::String^ ToUpper(System::String^ input) {
        try {
            std::string nativeInput = msclr::interop::marshal_as<std::string>(input);
            std::string result = instance->to_upper(nativeInput);
            return gcnew System::String(result.c_str());
        } catch (const std::runtime_error& e) {
            throw gcnew System::Runtime::InteropServices::ExternalException(gcnew System::String(e.what()));
        }
    }
};
----
+
Now create the C# application that uses the wrapper:
+
[source,csharp]
----
// Program.cs
using System;

class Program {
    static void Main() {
        MyClassWrapper myClass = new MyClassWrapper();
        
        try {
            string result = myClass.ToUpper("hello world");
            Console.WriteLine("Result: " + result);
            
            // Test with an empty string to trigger the exception
            result = myClass.ToUpper("");
            Console.WriteLine("Result: " + result);
        } catch (System.Runtime.InteropServices.ExternalException e) {
            Console.WriteLine("Caught an exception: " + e.Message);
        }
    }
}
----
+
Compile the C++ code into a DLL:
+
----
cl /c /EHsc my_class.cpp
----
+
Compile the wrapper:
+
----
cl /clr /EHsc /I"path\to\boost" MyClassWrapper.cpp my_class.obj /link /OUT:MyClassWrapper.dll
----
+
Finally, create a C# project (say, using Visual Studio), add a reference to the `MyClassWrapper.dll`, then build and run the application:
+
----
Result: HELLO WORLD
Caught an exception: Input string is empty
----

. *Does the Java Native Interface (JNI) work with the Boost libraries?*
+
Through the use of the Java Native Interface (JNI) or Java Native Access (JNA), developers can call Boost libraries from Java applications. It involves creating native methods in Java that are implemented in pass:[C++] and using Boost libraries as part of those implementations. Here is a simple example (without error handling or return values):
+
[source,cpp]
----
// C++ implementation
#include <jni.h>
#include "MyClass.h"

JNIEXPORT void JNICALL Java_MyClass_hello(JNIEnv* env, jobject obj) {
    MyClass myClass;
    myClass.hello();
}
----
+
[source,java]
----
// Java class
public class MyClass {
    static {
        System.loadLibrary("myclass");
    }
    
    private native void hello();
    
    public static void main(String[] args) {
        new MyClass().hello();
    }
}
----

Note:: Similar techniques can be applied to other languages, such as R, Ruby, Perl, and Lua, using their respective foreign function interfaces (FFI) or binding libraries. 

. *What is the industry consensus for the expected remaining lifespan for pass:[C++], and does any other language look like it might become the replacement for it?*
+
The expected remaining lifespan of the pass:[C++] programming language is generally considered to be long, probably spanning several decades. While it's difficult to assign a precise number of years, here's an overview of the factors contributing to this consensus:
+
* pass:[C++] is deeply embedded in many critical systems, including operating systems, game engines, real-time systems, financial systems, and large-scale infrastructure projects. The massive amount of existing code ensures that the language will be relevant for a long time as maintaining, updating, and interacting with this codebase will remain necessary.
* The Boost libraries and the pass:[C++] Standard place a strong emphasis on backward compatibility, which helps ensure that older code continues to work with new versions of the language.
* The pass:[C++] language continues to evolve, with regular updates to the standard (e.g., pass:[C++]11, pass:[C++]14, pass:[C++]17, pass:[C++]20, and pass:[C++]23). These updates introduce new features and improvements that keep the language modern and competitive.
* The pass:[C++] community, including the ISO pass:[C++] committee and Boost users, are highly active, ensuring that the language adapts to new programming paradigms, hardware architectures, and developer needs.
* High Performance - pass:[C++] remains one of the go-to languages for applications where performance is critical, such as gaming, high-frequency trading, and embedded systems. Its ability to provide low-level memory and hardware control while still supporting high-level abstractions makes it difficult to replace.
* For system-level programming and scenarios where fine-grained control over system resources is necessary, pass:[C++] is still unmatched.
* pass:[C++] is still widely taught in universities, especially in courses related to systems programming, algorithms, and data structures. As a teaching language, it instills principles of memory management, performance optimization, and object-oriented programming, which are valuable across many programming domains.
* pass:[C++] has a strong presence in specialized domains such as aerospace, robotics, telecommunications, and automotive software, where reliability, real-time performance, and low-level hardware access are critical. For example, some current EV manufacturers are using pass:[C++] and Unreal Engine to develop their in-car infotainment and control systems.
* While newer languages may rise in popularity for certain use cases, no other language currently offers the same combination of performance, control, and ecosystem that pass:[C++] provides, making it unlikely to be replaced any time soon.
+
Future technological shifts, such as advances in quantum computing or entirely new programming paradigms, could influence (increase or decrease) the lifespan of pass:[C++]. However, given its adaptability and entrenched role in many industries, pass:[C++] is expected to evolve alongside these changes rather than be replaced by them.

. *If I was to learn one other language, in addition to pass:[C++], what should it be to best prepare myself for an uncertain future?*
+
Python is often the top recommendation due to its versatility, simplicity, and wide application in growing fields like artificial intelligence (AI), machine learning (ML), rapid prototyping, and data science. And boost:python[] is there to help you integrate with the Boost libraries. Rust is another strong contender, especially if you are interested in systems programming and are looking for reliability and security. If you see the future as more cloud computing, then Go makes a strong case for itself.  And let's not forget that so much computing is now web based, so JavaScript deserves a mention here too. All of these languages offer valuable resources that complement pass:[C++] and prepare you for an uncertain future.

== Releases

. *How do I download the latest libraries?*
+
Go to https://www.boost.org/users/download/[Boost Downloads].

. *What do the Boost version numbers mean?*
+
The scheme is x.y.z, where x is incremented only for massive changes, such as a reorganization of many libraries, y is incremented whenever a new library is added, and z is incremented for maintenance releases. y and z are reset to 0 if the value to the left changes

. *Is there a formal relationship between Boost.org and the pass:[C++] Standards Committee?*
+
No, although there is a strong informal relationship in that many members of the committee participate in Boost, and the people who started Boost were all committee members.

. *Will the Boost.org libraries become part of the next pass:[C++] Standard?*
+
Some might, but that is up to the standards committee. Committee members who also participate in Boost will definitely be proposing at least some Boost libraries for standardization. Libraries which are "existing practice" are most likely to be accepted by the C++ committee for future standardization. Having a library accepted by Boost is one way to establish existing practice.

. *Is the Boost web site a commercial business?*
+
No. It is a non-profit.

. *Why do Boost headers have a .hpp suffix rather than .h or none at all?*
+
File extensions communicate the "type" of the file, both to humans and to computer programs. The '.h' extension is used for C header files, and therefore communicates the wrong thing about pass:[C++] header files. Using no extension communicates nothing and forces inspection of file contents to determine type. Using `.hpp` unambiguously identifies it as pass:[C++] header file, and works well in practice.

. *How do I contribute a library?*
+
Refer to the xref:contributor-guide:ROOT:index.adoc[]. Note that shareware libraries, commercial libraries, or libraries requiring restrictive licensing are all not acceptable. Your library must be provided free, with full source code, and have an acceptable license. There are other ways of contributing too, providing feedback, testing, submitting suggestions for new features and bug fixes, for example. There are no fees for submitting a library.


== Smart Pointers

. *What different types of smart pointers are there?*
+
The boost:smart_ptr[] library provides a set of smart pointers that helps in automatic and appropriate resource management. They are particularly useful for managing memory and provide a safer and more efficient way of handling dynamically allocated memory. The library provides the following types of smart pointers:
+
[disc]
* `boost::scoped_ptr`: A simple smart pointer for sole ownership of single objects that must be deleted. It's neither copyable nor movable. Deletion occurs automatically when the `scoped_ptr` goes out of scope.

* `boost::scoped_array`: Similar to `scoped_ptr`, but for arrays instead of single objects. Deletion occurs automatically when the `scoped_array` goes out of scope.

* `boost::shared_ptr`: A reference-counted smart pointer for single objects or arrays, which automatically deletes the object when the reference count reaches zero. Multiple `shared_ptr` can point to the same object, and the object is deleted when the last `shared_ptr` referencing it is destroyed.

* `boost::shared_array`: Similar to `shared_ptr`, but for arrays instead of single objects.

* `boost::weak_ptr`: A companion to `shared_ptr` that holds a non-owning ("weak") reference to an object that is managed by `shared_ptr`. It must be converted to `shared_ptr` in order to access the referenced object.

* `boost::intrusive_ptr`: A smart pointer that uses intrusive reference counting. Intrusive reference counting relies on the object to maintain the reference count, rather than the smart pointer. This can provide performance benefits in certain situations, but it requires additional support from the referenced objects.

* `boost::enable_shared_from_this`: Provides member function `shared_from_this`, which enables an object that's already managed by a `shared_ptr` to safely generate more `shared_ptr` instances that all share ownership of the same object.

* `boost::unique_ptr`: A smart pointer that retains exclusive ownership of an object through a pointer. It's similar to `std::unique_ptr` in the pass:[C++] Standard Library.

. *Can you give me a brief coding overview of how to use smart pointers efficiently?*
+
There are several types of smart pointers with different characteristics and use cases, so use them appropriately according to your program's requirements. Here are some common examples:

+
A `shared_ptr` is a reference-counting smart pointer, meaning it retains shared ownership of an object through a pointer. When the last `shared_ptr` to an object is destroyed, the pointed-to object is automatically deleted. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp(new int(10));
    // Now 'sp' owns the 'int'.
    // When 'sp' is destroyed, the 'int' will be deleted.
}
----
+
Note that `shared_ptr` objects can be copied, meaning ownership of the memory can be shared among multiple pointers. The memory will be freed when the last remaining `shared_ptr` is destroyed. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp1(new int(10));
    // Now 'sp1' owns the 'int'.
    boost::shared_ptr<int> sp2 = sp1;
    // Now 'sp1' and 'sp2' both own the same 'int'.
    // The 'int' will not be deleted until both 'sp1' and 'sp2' are destroyed.
}
----
+
A `weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object managed by a `shared_ptr`. It must be converted to `shared_ptr` in order to access the object. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp(new int(10));
    boost::weak_ptr<int> wp = sp;
    // 'wp' is a weak pointer to the 'int'.
    // If 'sp' is destroyed, 'wp' will be able to detect it.
}
----
+
A `unique_ptr` is a smart pointer that retains exclusive ownership of an object through a pointer. It's similar to `std::unique_ptr` in the pass:[C++] Standard Library. For example:
+
[source,cpp]
----
#include <boost/interprocess/smart_ptr/unique_ptr.hpp>

void foo() {
    boost::movelib::unique_ptr<int> up(new int(10));
    // Now 'up' owns the 'int'.
    // When 'up' is destroyed, the 'int' will be deleted.
}
----

== Standard Library

. *Where can I find the most complete documentation on the C++ Standard Library?*
+
Here, the https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library]. The Search feature is useful for locating individual components.

. *How can I be sure when I should use a Boost library or a component of the Standard Library?*
+
Most Boost libraries provide useful and advanced functionality unavailable in the Standard Library. A few Boost libraries have indeed been superseded by the Standard Library, but remain in Boost for backwards compatibility. To determine which you should use, given the choice, consider working through the following process.
+
Note:: When a Boost library is included in the Standard Library, not _all_ of the functionality provided is necessarily standardized. For example, boost:system[] has been standardized but still contains additional functionality not available in the standard. Although standardization might include all of the functionality of a Boost library, performance is not always identical and it can be of value to use the Boost version for higher performance (for example, boost:regex[]). In a few cases, the whole of the Boost library is standardized and the Boost version does not improve on performance (for example, boost:thread[]). 
+
.. Check the Boost library documentation, as their relationship to the Standard Library is sometimes documented. Both the Overview and the Release Notes are good sources of information for mentions of standardization.
.. The https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library] is also well documented. Check to see if the functionality you are looking for is now part of the standard. If you have specific features in mind, comparing the Boost and Standard library functions and classes should provide you with a definitive answer on which to use.
.. If you are less certain of the specific features you need, developers often discuss the status and relevance of Boost libraries in comparison to the standard. Browse, or ask a question in, https://stackoverflow.com/search?q=Boost&s=f447efbc-2ea3-4846-a5d3-0f8676b3f65c[Stack Overflow], https://www.reddit.com/search/?q=Boost+libraries&type=link&cId=28644139-c8b3-48a5-87b6-0c9822188ed4&iId=7f450c5d-6180-4538-a39f-7df7876df4e9&onetap_auto=true&one_tap=true[Reddit], or the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers Mailing List].
.. If you want to dig into the source code, check the activity in the https://github.com/boostorg/boost/tree/master/libs[Boost library's GitHub repository]. Libraries that have been largely superseded have less recent activity compared to those still actively developed and extended. Also check Release Notes for mentions of deprecations or recommendations.
.. Current examples of libraries where you should now use the Standard Library include boost:smart_ptr[] (use `std::shared_ptr`, `std::unique_ptr` etc.), boost:thread[] (use `std::thread`), boost:chrono[] (use `std::chrono`), and boost:random[] (use `std::rand`). Referring to the documentation for these might help show the language used when discussing the relationship with the Standard Library.

. *Are there any Boost libraries currently being considered for inclusion in the Standard Library?*
+
Yes, currently the functionality of two Boost libraries are being considered:
+
.. boost:lambda2[] : for details refer to https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3171r0.html[Adding functionality to placeholder types]
.. boost:fiber[] : for details refer to https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r17.pdf[fiber_context - fibers without scheduler]

. *What is the current status of the Standard Library and when is the next release?*
+
*C++ 2026* is slated as the next full release, for details refer to https://isocpp.org/std/status[Current Status].


== Templates

. *What are pass:[C++] templates?*
+
pass:[C++] templates are a powerful feature of the language that allows for generic programming. They enable the creation of functions or classes that can operate on different data types without having to duplicate code.

. *What are function templates in pass:[C++]?*
+
Function templates are functions that can be used with any data type. You define them using the keyword template followed by the template parameters. Function templates allow you to create a single function that can operate on different data types.

. *What is template specialization in pass:[C++]?*
+
Template specialization is a feature of pass:[C++] templates that allows you to define a different implementation of a template for a specific type or set of types. It can be used with both class and function templates.

. *What are the benefits and drawbacks of using templates in pass:[C++]?*
+
The benefits of using templates include code reusability, type safety, and the ability to use generic programming paradigms. The drawbacks include potentially increased compile times, difficult-to-understand error messages, and complexities associated with template metaprogramming.

. *How can I use templates to implement a generic sort function in pass:[C++]?*
+
Here's a simple example of how you might use a function template to implement a generic sort function:
+
[source,cpp]
----
template <typename T>
void sort(T* array, int size) {
    for(int i = 0; i < size; i++) {
        for(int j = i + 1; j < size; j++) {
            if(array[i] > array[j]) {
                T temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
        }
    }
}
----
+
This function can now be used to sort arrays of any type (that supports the `<` and `>` operators), not just a specific type.

== See Also

* xref:contributor-guide:ROOT:contributors-faq.adoc[Contributor Guide FAQ]
* xref:explore-the-content.adoc[]
* xref:resources.adoc[]

