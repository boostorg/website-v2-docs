////
Copyright (c) 2024 The C++ Alliance, Inc. (https://cppalliance.org)

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Official repository: https://github.com/boostorg/website-v2-docs
////
= Frequently Asked Questions
:navtitle: FAQ

This section contains answers to the common questions that new developers to Boost often have.

== Topics

[square] 
* <<C++ Library Programming>>
* <<Combining Libraries>>
* <<Compatibility>>
* <<Debugging>>
* <<Dependencies>>
* <<Documentation>>
* <<Graphics and Games>>
* <<ISO C++ Committee Meetings>>
* <<Libraries>>
* <<Licensing>>
* <<Metaprogramming>>
* <<Modular Boost>>
* <<Numbers>>
* <<Other Languages>>
* <<Production and Debug Builds>>
* <<Reflection>>
* <<Releases>>
* <<Safe C++>>
* <<Smart Pointers>>
* <<Standard Library>>
* <<Templates>>
* <<Types>>
* <<See Also>>

Note:: The code samples in these topics was written and tested using Microsoft Visual Studio (Visual C++ 2022, Console App project) with Boost version 1.88.0.

== C++ Library Programming

. *What is involved in using a Boost header-only library?*
+
After installing the Boost libraries, not much, just include the libraries you want. Here is an example (`example1.cpp`) using boost:multiprecision[]:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <iostream>

// Alias for a high-precision floating-point type
using namespace boost::multiprecision;
using BigFloat = cpp_dec_float_50;

int main() {
    BigFloat a = 1.0 / 3.0;
    BigFloat b = sqrt(BigFloat(2));

    // Note that setprecision has been specified as slightly longer than the floating point numbers
    std::cout << "1/3 with high precision: " << std::setprecision(51) << a << std::endl;
    std::cout << "Square root of 2: " << std::setprecision(51) << b << std::endl;

    return 0;
}
----
+
Compile with:
+
[source,text]
----
g++ -std=c++17 example1.cpp -o example1
----
+
No linking is required, just run the program!

. *What is involved in using a Boost compiled-binary library?*
+
Using a compiled-binary library involves linking to the library, and any dependent libraries that are also compiled. Here is an example (`example2.cpp`) using boost:filesystem[].
+
[source,cpp]
----
#include <boost/filesystem.hpp>
#include <iostream>
#include <fstream>

namespace fs = boost::filesystem;

int main() {
    fs::path filePath("example.txt");

    if (fs::exists(filePath)) {
        std::cout << "File exists: " << filePath.string() << std::endl;
    } else {
        std::cout << "File does not exist, creating it..." << std::endl;
        std::ofstream file(filePath.string());
        file << "Hello, Boost.Filesystem!";
        file.close();
    }

    return 0;
}
----
+
This requires an extra step before running, linking to both boost:filesystem[] _and_ boost:system[]. We need to link to boost:system[] because boost:filesystem[] calls `boost::system::generic_category()` - for error handling - and this call is _only_ defined in the compiled version of boost:system[]:
+
[source,text]
----
g++ -std=c++17 example2.cpp -o example2 -lboost_filesystem -lboost_system
----
+
Now you can run your program.
+
Notes:: The example compiler used here is GNU pass:[C++]. If you are using the Clang compiler, simply replace `pass:[g++]` with `pass:[clang++]`. On macOS, if Boost is installed via Homebrew, you might need to specify the paths further:
+
`pass:[clang++ -std=c++17 example2.cpp -o example2 -I/usr/local/include -L/usr/local/lib -lboost_filesystem -lboost_system]`
+
If you are using MSVC, and the libraries are in the default path, then the command would be:
+
`pass:[cl /std:c++17 example2.cpp /Fe:example2.exe /link boost_filesystem.lib boost_system.lib]`


. *Given a choice, when should I use header-only or compiled-binary libraries?*
+
Depends on your priorities:
+
[cols="1,2,2",stripes=even,options="header",frame=none]
|===
| *Priority* | *Header-Only* | *Compiled-Binary*
| Ease of Use | Yes - Easier (just include)	| No -  Requires linking
| Compilation Time | No -  Slower | Yes - Faster
| Binary Size | No -  Larger (possible code duplication) | Yes - Smaller
| Performance | Yes - Optimized via inlining | Yes - Optimized via specialized builds
| Portability | Yes - Highly portable | No -  Requires platform-specific builds
| Debugging | No -  Harder (complex errors with templated code) | Yes - Easier
| ABI Stability | No -  Less stable | Yes - More stable
|===
+
Also, with a header-only library the compiler has full visibility of the code, allowing inlining and optimizations that might not be possible with separately compiled binaries. This can reduce function call overhead when optimizations are applied. Since no precompiled binaries are needed, projects using header-only libraries are easier to distribute and deploy.
+
However, header-only libraries are compiled within each project, so any minor changes (even updates) can lead to unexpected behavior due to template changes. Shared libraries with well-defined Application Binary Interfaces (ABIs) offer better versioning control.
+
Header-only libraries are certainly easier to get going with. To optimize for better stability and debugging, and reducing binary size, refer to the next few questions on how to create binaries for header-only code - typically, when your project is becoming stable.

. *Can I use C++20 Modules to precompile header-only libraries and import them when needed?*
+
Not reliably or consistently. Boost libraries are not currently written as pass:[C++]20 modules. They use traditional headers, macros, and complex template structures that don't cooperate well with the pass:[C++]20 export module syntax.
+
As a workaround, consider using old-fashioned header files. For example, for `boost_module.hpp`:
+
[source,cpp]
----
#pragma once
#include <boost/multiprecision/cpp_dec_float.hpp>

using BigFloat = boost::multiprecision::cpp_dec_float_50;
----
+
Then for the main code:
+
[source,cpp]
----
#include "boost_module.hpp"
#include <iostream>

int main() {
    BigFloat x = 1.0 / 3.0;
    std::cout << "1/3 with high precision: " << std::setprecision(51) << x << std::endl;
    return 0;
}

----
+
Even if Boost were module-friendly, `cpp_dec_float_50` is a template instantiated from a header, and exporting it in a module interface would require exposing a lot of detail that header-only libraries don't support out of the box.

. *Can I create a Static Library from header-only libraries and link when needed?*
+
Yes, even if the library is header-only, you can wrap it in a `.cpp` file, compile it into a static `.a` or `.lib` file, and link it. Start by creating a wrapper source file (`boost_wrapper.cpp`) that includes the header-only Boost libraries:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>

boost::multiprecision::cpp_dec_float_50 dummy_function() {
    return 1.0 / 3.0; // Forces compilation of template instantiation
}
----
+
Now, compile it into a static library:
+
[source,text]
----
g++ -c boost_wrapper.cpp -o boost_wrapper.o
ar rcs libboost_wrapper.a boost_wrapper.o
----
+
Use it in your code:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <iostream>

int main() {
    boost::multiprecision::cpp_dec_float_50 x = 1.0 / 3.0;
    std::cout << "1/3: " << x << std::endl;
    return 0;
}
----
+
Compile and link:
+
[source,text]
----
g++ main.cpp -L. -lboost_wrapper -o main
----
+
Note:: One advantage of this approach is it avoids re-parsing and re-instantiating templates in every translation unit.

. *Can I create a precompiled header (PCH) that imports Boost libraries?*
+
Yes, a precompiled header should enable faster recompilation when only the main code changes. And, unlike modules, it works in older pass:[C++] versions.
+
For example, create an hpp file (boost_pch.hpp) containing the required libraries:
+
[source,cpp]
----
// boost_pch.hpp
#include <boost/multiprecision/cpp_dec_float.hpp>
----
+
Precompile it into a `.gch` file:
+
[source,text]
----
g++ -std=c++17 -x c++-header boost_pch.hpp -o boost_pch.hpp.gch
----
+
Use it in your code:
+
[source,cpp]
----
#include "boost_pch.hpp" // Uses precompiled header

int main() {
    boost::multiprecision::cpp_dec_float_50 x = 1.0 / 3.0;
    std::cout << "1/3: " << x << std::endl;
    return 0;
}
----
+
Typically, when your project starts becoming "large" use of compiled libraries becomes more relevant.

. *In the programming world, what qualifies as a small, medium, or large project?*
+
While not perfect, _lines of code_ is a quick way to classify project sizes:
+
[cols="1,1",stripes=even,options="header",frame=none]
|===
| *Project Size* | *Lines of Code Estimate*
| Small	| less than 10,000
| Medium | 10,000 to 100,000
| Large	| 100,000 to 1,000,000
| Enterprise/Monolithic | more than 1,000,000
|===
+
Or possibly classify a project by the number of developers:
+
[cols="1,1",stripes=even,options="header",frame=none]
|===
| *Project Size* | *Developers*
| Small	| less than 5
| Medium | 6 to 50
| Large	| 51+
| Enterprise/Monolithic | Hundreds, across multiple time-zones
|===
+
There are other metrics too - if your incremental build takes minutes, it's getting large. If a full rebuild takes hours, it's definitely a large project. If the dependency tree is deep, requiring fine-grained modularization, it's large.
+
Note:: Size alone is not a perfect measure of complexity. A templated metaprogramming-heavy project might be "large" in complexity but only a few thousand lines. Or a UI-heavy application might have tons of boilerplate but be relatively simple. Boost Libraries are available to help prevent a "large" project becoming a "beast"!

. *When does a coding project become a "beast"?*
+
A coding project becomes a beast when two or more of the following conditions are met:
+
** Build times are measured in coffee breaks - if compiling takes longer than making (and drinking) a cup of coffee, it's a beast!
** When you start considering distributed builds or caching everything, it's serious.
** No one developer knows how everything works anymore.
** The project is in "dependency hell" - adding one more library requires resolving a cascade of conflicts. Or, you start saying, "Do we really need this feature?" just to avoid the dependency headache.
** Debugging feels like archaeology - code from years ago still exists, but no one remembers why. Or, comments like `// DO NOT TOUCH - IT JUST WORKS` litter the source code.
** Refactoring is a nightmare - a simple rename breaks hundreds of files, or "Let's rewrite it from scratch" starts sounding reasonable.
** Multi-minute CI/CD pipelines - your test suite takes longer to run than a lunch break.
** Contributors live in fear of merge conflicts.

== Combining Libraries

. *Can you give me some examples of Boost libraries that developers have found work well together?*
+
Many Boost libraries are designed to be modular, yet complementary, and over the years, developers have discovered powerful combinations of libraries that work well together. Here are some groups:
+
* If you are building an *Asynchronous Networking Stack*, then the following libraries mesh naturally: boost:asio[] for core asynchronous I/O and networking, boost:system[] for error codes that are used in Asio error handling, boost:thread[] or boost:fiber[] for managing threads or fibers in concurrent code, boost:chrono[] for working with timeouts and deadlines, and boost:bind[] or boost:function[] for callbacks and handler binding in Asio.
+
If the network supports financial systems, in particular high-frequency trading, then add boost:lockfree[] to support low-latency data structures, and boost:multiprecision[] for high-precision arithmetic.
+
* Say you are working on *Compile-Time Metaprogramming and Reflection*, then the following libraries enable expressive and powerful template code, with strong introspection and static analysis at compile time, reducing run-time cost: boost:hana[] or boost:mp11[] for high-level metaprogramming, boost:fusion[] provides sequence manipulation for structs and tuples at compile time, boost:type-traits[] for query and transform types, and boost:static-assert[] or boost:assert[] to validate assumptions during compile-time logic.
+
* A quite different field is *Simulation, Geographic Information Systems (GIS), Robotics, and CAD*. For this you need accurate, type-safe modeling of space, motion, and physical quantities, all interoperable in simulations or mathematical domains. The following provide this: boost:geometry[] for the algorithms in 2D/3D spatial operations, boost:units[] for strongly-typed physical units to prevent dimensional errors, boost:qvm[] for lightweight vector and matrix algebra, boost:math[] adds special functions, statistical distributions, numerical accuracy, and boost:numeric/interval[] can represent ranges of values that may contain uncertainty. In robotics in particular, you might need boost:thread[] to support parallel sensor processing. Also, boost:serialization[] might also help with state persistence.
+
* If you are building a *Test Suite*, say with unit testing and regression tests, consider adding to boost:test[] the following: boost:type-traits[] to inspect and verify types in test cases, boost:optional[] or boost:variant[] or boost:outcome[] to represent and test optional or alternative outcomes, boost:preprocessor[] to generate test cases or datasets at compile time, and finally boost:format[] or boost:locale[] for diagnostics, error reporting, and  internationalized tests.
+
* On a similar vein to testing is *Logging*. Logging infrastructure is well supported by boost:log[]. boost:property-tree[] might help with configuration and data trees, boost:circular_buffer[] for bounded memory logging, and boost:program-options[] for a command-line interface (perhaps for embedded systems).
+
* As a final example consider *Saving/Restoring State, Remote Procedure Calls (RPC), Configuration Files, Distributed Systems*. The following collection covers all aspects of data flow - loading, storing, transforming, and parsing—all in a type-safe, extensible style: boost:serialization[] for the core for serializing pass:[C++] objects to/from streams, boost:variant[] or boost:optional[] to serialize complex, dynamic types, boost:property-tree[] for easy access to config files (JSON, XML, or INI) and boost:spirit[] for parsing domain-specific formats into structured data.
+
For deeper examples of multiple libraries, including working source code, refer to xref:common-introduction.adoc[Common Scenarios] and xref:advanced-introduction.adoc[Advanced Scenarios].

. *I want to build a cross-platform system, right from the start. What libraries should I use as core to that system?*
+
Desktop applications like text editors, project managers and utilities often need cross-platform compatibility, user input processing, and dynamic plugins via signal-slot mechanisms. Consider boost:filesystem[] to provide the file management, boost:locale[] for use in multiple regions, boost:signals2[] to support an event system, and boost:regex[] for structured text parsing.

. *Are there any combinations of Boost libraries that experience has shown do not play well together?*
+
Not in a broad sense, Boost pass:[C++] libraries are designed with a high degree of interoperability. However, there are always nuances when multiple libraries have overlapping functionality, conflicting macros, or different assumptions about thread safety, memory management, or initialization. Issues can usually be avoided with careful design, for example:

* boost:signals2[] internally uses boost:thread[] for managing asynchronous signal connections. However, there have been instances where thread safety issues arise when these two libraries are used in parallel. If not handled properly, it can lead to deadlocks or race conditions, especially in multithreaded environments. Always ensure that signals are disconnected properly and thread-safe operations are applied where needed.
* Both boost:filesystem[] and boost:regex[] perform some filesystem operations and string manipulation that can lead to conflicts when used in combination, especially if Regex is processing filenames or paths that contain special characters (for example, slashes or backslashes in Windows paths). When working with filenames and regular expressions, it's best to sanitize the inputs carefully before passing them on.
* boost:mp11[] and boost:hana[] both work with metaprogramming, often with overlapping functionality, but their usage patterns can conflict. MP11 uses a more classic, compile-time only, and more explicit metaprogramming model, while Hana includes both compile-time and run-time metaprogramming functions, which introduce ambiguity when mixing the two libraries. Best to choose one of these libraries, unless you can ensure clean separation between the two.
* The interaction between boost:serialization[] (for serializing and deserializing objects) and boost:python[] (for integrating pass:[C++] code with Python) can be tricky when serializing Python objects. Issues like memory management conflicts or incorrect serialization of Python objects can occur, especially with Python's dynamic typing system. Wrapping Python objects in pass:[C++] classes with explicit serialization mechanisms may be necessary.
* When using asynchronous I/O with boost:asio[] and regular expressions with boost:regex[], conflicts can arise, particularly with blocking operations in `boost::asio::io_service` or `boost::asio::strand`. Regex can be CPU-intensive and might block the main event loop of Asio, leading to performance issues or deadlocks. Use non-blocking or asynchronous alternatives (separate threads) for Regex operations in the context of Asio.
* boost:pool[] is a custom memory pool allocator that can cause issues when used with boost:smart_ptr[] (such as `boost::shared_ptr` or `boost::scoped_ptr`) since these smart pointers manage memory differently. The interaction between custom memory pools and reference-counted pointers can lead to memory leaks or double-free errors if not handled correctly. When using Pool with smart pointers, ensure that custom allocators are compatible with the reference-counting behavior of smart pointers. Consider using `boost::shared_ptr` with `boost::pool_allocator` if you're using custom memory pools.
* Both boost:spirit[] (a parsing library) and boost:serialization[] involve significant template metaprogramming, which can result in large compile times and potential conflicts in template instantiations. The combination of these libraries in the same project can exacerbate compilation times and, in rare cases, cause conflicts in template instantiation or symbol resolution. Use these libraries in different parts of your project and limit cross-dependencies.
* boost:test[] is a robust testing framework, while boost:thread[] is used for threading. Problems can occur if your tests are not properly isolated from thread contexts, or if tests involving multiple threads cause race conditions or deadlocks that aren't immediately visible. Use proper synchronization techniques in multi-threaded tests to avoid race conditions. When testing threaded code, use the correct testing tools provided by Test, such as `BOOST_THREAD_TEST`, to ensure proper isolation of tests and reduce flaky test results.
+
In general, to avoid problems, always test combinations of libraries early, to ensure proper synchronization and error handling.

. *Is there a checklist to work through to ensure I have covered my bases when combining libraries?*
+
The following checklist should be a good start:
+
*Boost C++ Library Integration Checklist*
+
- *Build and Linking*
+
- [ ] Confirm which Boost components are *header-only* vs *require linking*.
- [ ] Use a *consistent Boost version* across the codebase.
- [ ] Link required Boost libraries explicitly (for example, `-lboost_filesystem`, `-lboost_thread`).
- [ ] Use CMake's `find_package(Boost REQUIRED COMPONENTS ...)` correctly if applicable.
+
*Dependencies and Size*
+
- [ ] Audit *transitive dependencies* with tools like the https://github.com/boostorg/bcp/[Boost Copy Tool (bcp)] and https://pdimov.github.io/boostdep-report/[Boost Dependency Report].
- [ ] Include *only the headers you need* to keep compile times fast and code lean.
+
*Preprocessor Macros*
+
- [ ] Check for key macros like `BOOST_NO_EXCEPTIONS`, `BOOST_ASSERT`, `BOOST_DISABLE_ASSERTS`.
- [ ] Avoid macro name collisions (for example, `bind`, `min`, `max`) by careful header ordering or `#undef`.
+
*Thread Safety*
+
- [ ] Ensure Boost libraries used are *thread-safe* in your usage context.
- [ ] Use thread-safe variants (boost:signals2[], boost:log[] with thread-safe sinks) as needed.
+
*Clean Code Practices*
+
- [ ] Encapsulate low-level Boost operations behind clean APIs.
- [ ] Apply *RAII* for all resource management (files, sockets, locks).
- [ ] Handle exceptions and error codes *consistently* across Boost modules.
+
*Debugging and Tooling*
+
- [ ] Prepare for *template error verbosity* (for example, with boost:spirit[], boost:mp11[], boost:hana[]).
- [ ] Verify *debug symbol generation* and *stack traces* involving Boost types.
+
*Documentation and Discoverability*
+
- [ ] Document Boost macros and configuration choices in the build setup or source files.
- [ ] Link to official Boost documentation: https://www.boost.org/doc/libs/.
+
*Testing and CI*
+
- [ ] Add *unit tests* for modules using Boost.
- [ ] Test both *success* and *failure* paths (for example, file-not-found, timeout, parsing errors).
- [ ] Test across multiple Boost versions/platforms if possible in CI pipelines.
+
*Integration with Other Libraries*
+
- [ ] Watch for macro conflicts or settings when combining Boost with libraries like https://www.qt.io/[Qt], https://pocoproject.org/[Poco], https://opencv.org/[OpenCV].
- [ ] Guard against *duplicate symbols* or *conflicting linkage* when using static/shared Boost libs.
+
Refer also to xref:boost-macros.adoc[] and xref:reduce-dependencies.adoc[].

== Compatibility

. *Can I use Boost with my existing pass:[C++] project?*

+
Yes, Boost is designed to work with your existing pass:[C++] code. You can add Boost libraries to any project that uses a compatible pass:[C++] compiler.

. *Can I use Boost libraries with the new pass:[C++] standards?*

+
Yes, Boost libraries are designed to work with modern pass:[C++] standards including pass:[C++11], pass:[C++14], pass:[C++17], pass:[C++20], and pass:[C++23].

. *What flavors of Linux are supported by the Boost libraries?*
+
Boost libraries are generally compatible with most Linux distributions, provided that the distribution has an up-to-date pass:[C++] compiler. This includes:
+
* Ubuntu
* Fedora
* Debian
* CentOS
* Red Hat Enterprise Linux
* Arch Linux
* openSUSE
* Slackware
* Gentoo
* macOS

. *How can I be sure that a library I want to use is compatible with my OS?*
+
While Boost strives to ensure compatibility with a wide range of compilers and systems, not every library may work perfectly with every system or compiler due to the inherent complexities of software. The most reliable source of information is the specific https://www.boost.org/doc/libs/[Boost library's documentation].


== Debugging

. *What support does Boost provide for debugging and testing?*
+
Boost provides boost:test[] for unit testing, which can be an integral part of the debugging process. It also provides the boost:stacktrace[] library that can be used to produce useful debug information during a crash or from a running application. Refer also to https://www.boost.org/doc/libs/latest/libs/libraries.htm#Correctness[Category: Correctness and testing].

. *How do I enable assertions in Boost?*
+
Boost uses its own set of assertion macros. By default, `BOOST_ASSERT` is enabled, but if it fails, it only calls `abort()`. If you define `BOOST_ENABLE_ASSERT_HANDLER` before including any Boost header, then you need to supply `boost::assertion_failed(msg, code, file, line)` and `boost::assertion_failed_msg(msg, code, file, line)` functions to handle failed assertions.

. *How can I get a stack trace when my program crashes?*
+
You can use the boost:stacktrace[] library to obtain a stack trace in your application. You can capture and print stack traces in your catch blocks, in signal handlers, or anywhere in your program where you need to trace the execution path.

. *Can I use Boost with a debugger like GDB or Visual Studio?*
+
Yes, Boost libraries can be used with common debuggers like https://sourceware.org/gdb/[GDB] or https://visualstudio.microsoft.com/downloads/[Visual Studio]. You can set breakpoints in your code, inspect variables, and execute code step by step. Boost doesn't interfere with these debugging tools.

. *Are there any debugging tools specifically provided by Boost?*
+
Boost doesn't provide a debugger itself. The libraries tend to make heavy use of assertions to catch programming errors, and they often provide clear and detailed error messages when something goes wrong.

. *What are best practices when using Boost Asserts?*
+
Boost provides the assertion `boost::assert`. Best practices when using this are:

+
[disc]
* _Use Assertions for Debugging and Development_: Boost assertions should primarily be used during the debugging and development phase of your application. Assertions are designed to catch programming errors, not user errors.

* _Assert Conditions That Should Never Occur_: You should only assert conditions that you believe can never occur during normal operation of your application. If there's a chance that a condition may occur, handle it as an exception or error rather than asserting.

* _Provide Meaningful Assert Messages_: Boost assertions allow you to provide a message alongside your assertion. Use this feature to provide meaningful context about why an assertion failed.

* _Consider Performance Impact_: Boost assertions can slow down your application. In performance-critical code, consider disabling them in the production version of your application.

. *What is the recommended approach to logging, using `boost::log`?*
+
[disc]
* _Use Severity Levels_: boost:log[] supports severity levels, which you can use to categorize and filter your log messages. This can help you control the amount of log output and focus on what's important.

* _Provide Context_: boost:log[] allows you to attach arbitrary data to your log messages, such as thread IDs, timestamps, or file and line information. Use this feature to provide context that can help you understand the state of your application when the log message was generated.

* _Use Asynchronous Logging_: If logging performance is a concern, consider using the asynchronous logging feature. This allows your application to continue executing while log messages are processed in a separate thread.

* _Format Your Log Output_: boost:log[] supports customizable log formatting. Use this feature to ensure that your log output is easy to read and contains all the information you need.

* _Handle Log Rotation_: If your application produces a lot of log output, consider setting up log rotation, which is supported. This ensures that your log files don't grow indefinitely.

[[dependencies]]
== Dependencies

. *What is meant by a "dependency" and the phrase "dependency chain"?*
+
In the context of this FAQ, a _dependency_ is any other library, Boost or Standard or third-party, that a Boost library requires. A _primary dependency_ is a library the top-level library explicitly includes, a _secondary dependency_ is a library that one of the primary, or other secondary dependency, includes. 
+
Boost libraries are modular, but they can depend on each other for various functionalities - for example, boost:asio[] relies on boost:system[] for error codes.
+
In general, taking dependencies can add a lot of value and reduce development time considerably. Boost libraries are carefully reviewed and tested to minimize dependency issues.
+
As often with powerful concepts, there are pitfalls. Dependencies can lead to "dependency chains," where including one library pulls in others that may not be needed by your project. 

. *What issues do library developers have to address when managing dependencies?*
+
This includes handling several awkward situations: _Version Conflicts_ - when different dependencies require incompatible versions of the same library, _Transitive Dependencies_ - when a library pulls in additional, indirect dependencies that you may not even realize are part of your project, _Bloat_ - when the sheer number of dependencies makes the build or runtime environment large, slow, or error-prone, and _Security Risks_ - when outdated or unnecessary dependencies introduce vulnerabilities.
+
In forum posts you might come across the following phrases, each describing a frustration with dependencies:

* "Dependency creep" - the gradual accumulation of dependencies over time, often unnecessarily.
* "Library fatigue" - the exhaustion or frustration of constantly managing and keeping track of too many libraries.
* "Transitive dependency nightmare" - specifically refers to the frustration caused by indirect dependencies that you don't directly control.
* "Package spaghetti" or "Dependency spaghetti" - a messy tangle of interconnected dependencies.
* "Build chain chaos" - can refer to the difficulties in managing the build process when dependencies are involved.

. *What is meant by a "standalone" library?*
+
A _standalone_ library is one where there are no dependencies (or, in reality, few), or the library depends only on the https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library]. Sometimes separate standalone versions of specific libraries are available, though they might be lightweight versions and not have parity of functionality with the non-standalone version.

. *What can I do to minimize the number and impact of dependencies?*
+
A simple question but with a non-trivial answer. Consider working through this list of strategies and carefully applying when you can:
+
.. Avoid including headers that aren't directly needed. When building Boost with https://www.bfgroup.xyz/b2/[B2], you can exclude certain parts of Boost to minimize dependencies. For example, use the `--with-[library]` flag to build only the libraries you need. Say you only want boost:system[] and boost:filesystem[], then enter: `./b2 --with-system --with-filesystem`. This will install only these two libraries, and their essential dependencies. Refer to xref:building-with-cmake.adoc[] if you are using CMake as your build tool.
.. Read the library documentation to find macros that are available to remove unneeded functionality. For example, when using boost:asio[], if support for timers or SSL are unneeded, then enter the statement: `#define BOOST_ASIO_DISABLE_SSL`. Refer to xref:reduce-dependencies.adoc[] for many more examples.
.. For powerful libraries like boost:asio[], you can include only the headers you need, such as `<boost/asio/io_context.hpp>` rather than its parent `<boost/asio.hpp>`.
.. Use forward declarations where possible instead of including full headers.
.. Use a https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library] alternative if one exists, and has equivalent functionality and performance. For example, boost:variant[] could be replaced with `std::variant`.
.. Use the Header-Only Mode (where possible). Many Boost libraries are header-only, meaning they don't require linking against precompiled binaries or additional dependencies. Examples include boost:optional[], boost:variant[], and boost:type_traits[]. For details of the binary requirements of Boost libraries refer to xref:header-organization-compilation.adoc#compiled[Required Compiled Binaries] and xref:header-organization-compilation.adoc#optionalcompiledbinaries[Optional Compiled Binaries]. For example, boost:asio[] has both header-only and compiled modes and you can configure it to work as header-only by defining the macro: `#define BOOST_ASIO_SEPARATE_COMPILATION`.
.. For experienced developers only, consider commenting out unused code. This approach is possible but risky because it modifies library source code (Boost libraries are open-source), making updates and maintenance more challenging. It involves first identifying the parts of the library that introduce unnecessary dependencies and then commenting out the sections of source code or headers that you don't need (such as unused features, optional functionality, error handling code). Finally, rebuild the library and check it compiles and links and runs without unwanted side-effects.

. *Are there any tools specific to Boost that help manage dependencies?*
+
Yes, the https://github.com/boostorg/bcp/[Boost Copy Tool (bcp)] is designed to help with dependency management. It allows you to extract a subset of the libraries and their dependencies into a separate directory, minimizing what gets pulled into your project. Install the tool and run `bcp [library-name] [output-dir]`. Review the output directory to ensure that only the necessary dependencies are included. For example, if you're using boost:regex[], enter `bcp regex ./boost_subset` and review the contents of your `./boost_subset` directory.
+
There is also the https://pdimov.github.io/boostdep-report/[Boost Dependency Report], which goes into detail on the primary and secondary dependencies of all the libraries.

. *Are there generally available tools that help with dependency issues?*
+
You can use static analysis tools, like https://clang.llvm.org/extra/clang-tidy/[Clang-Tidy] or https://cppcheck.sourceforge.io/[Cppcheck], to analyze your application and see which parts of any dependency are actually being used. Once identified, you can both remove unnecessary headers or dependencies, and perhaps rewrite portions of your code to avoid unnecessary functionality.

[[documentation]]
== Documentation

. *Who writes the documentation for a Boost library?*
+
The library authors are responsible for all the documentation specific to their library. The authors are clearly the most knowledgeable on the design decisions, architecture, API calls, inner workings, and potential limitations of their library. Contributor guidelines on documentation help maintain consistency in styling and content across the library collection. Refer to xref:contributor-guide:ROOT:docs/layout.adoc[].

. *If I find an issue with the documentation, or would like to suggest an improvement, can I make a formal request?*
+
Yes you can, file an issue on the library. Typically library authors welcome feedback that enhances the useability of their work - refer to xref:reporting-issues.adoc[].

. *Has any Boost library documentation been translated into languages other than English?*
+
There is no formal localization of library documentation. However, translation efforts have existed at various times for Japanese, Chinese and Russian. Most current effort is into Japanese - refer to https://boostjp.github.io/[boostjp].

. *If I wanted to translate my favorite library documentation into my native language, who do contact to get started?*
+
The copyright ownership of library documentation remains with the documentation authors. Contact the authors via the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers Mailing List] if you are inspired to take on this task.

. *Have there ever been efforts to localize not just the documentation but the API calls themselves?*
+
Not for the Boost libraries. Microsoft did experiment with localized API calls many years ago, though the project was abandoned as way too complicated, unmaintainable, and not particularly useful.

== Graphics and Games

. *If I wanted to use the Boost libraries in conjunction with a graphics library, to write a 3D game, what graphics library would be most compatible with Boost?*
+
The following libraries work well with Boost because they don't impose custom build systems or incompatible runtime dependencies — they're just pass:[C++] libraries, and that's exactly Boost's domain.
+
[cols="1,2,2",stripes=even,options="header",frame=none]
|===
| *Graphics Library*   | *Why It's Compatible with Boost* | *Ideal Boost Libraries to Pair*
| https://github.com/OGRECave[*Ogre3D*]         | Modular, C++03/11 compatible, uses STL-style containers and patterns similar to Boost | boost:filesystem[], boost:smart_ptr[], boost:signals2[], boost:asio[]
| https://github.com/bkaradzic/bgfx[*bgfx*]           | Minimal dependencies, works well with Boost threading and filesystem    | boost:thread[], boost:lockfree[], boost:system[] 
| https://magnum.graphics/[*Magnum*]         | Modern, header-only components, great for C++17+ and fits Boost idioms | boost:geometry[], boost:math[], boost:uuid[] 
| https://github.com/buildaworldnet[*IrrlichtBAW*]    | Easy to integrate with Boost for physics, networking, or file I/O        | boost:filesystem[], boost:serialization[], boost:program_options[] 
| https://www.vulkan.org/[*Vulkan]* | Boost helps manage complexity: asynchronous loading, configuration, math, logging     | boost:asio[], boost:log[], boost:multi-array[], boost:gil[]
|===

. *What would be the simplest solution to 3D graphics and Boost working in harmony?*
+
Probably the https://github.com/OGRECave[**Ogre3D**]  graphics library, working with boost:filesystem[] for asset control and boost:asio[] for networking.

. *What games systems are well matched with Boost libraries?*
+
Here's how Boost might slot into a 3D game engine:
+
[cols="1,2,2",stripes=even,options="header",frame=none]
|===
| *System*  | *Boost Library*  | *Purpose* 
| Asset Loading  | boost:filesystem[], boost:iostreams[]         | Cross-platform file handling  
| Entity Updates | boost:signals2[], boost:variant2[]| Event-driven game logic       
| Network Multiplayer        | boost:asio[]           | Async client/server or peer/peer communication         
| Configuration  | boost:program_options[], boost:property_tree[]| Game settings, config files   
| Logging        | boost:log[], boost:stacktrace[]   | Diagnostics and crash reporting           
| Physics or AI Math         | boost:numeric/ublas[] , boost:geometry[], boost:random[] | Physics, spatial logic        
| Texture/Image Manipulation | boost:gil[]| Procedural textures, screenshots          
| Multithreading | boost:thread[], boost:lockfree[], boost:fiber[]          | Game loop or rendering pipeline parallelism
|===

. *Are there any graphics libraries that are problematic when combined with Boost libraries?*
+
Both https://www.learnqt.guide/qt-graphics-view-framework[*Qt*] and https://www.unrealengine.com/en-US[*Unreal Engine*] are heavy frameworks that conflict with Boost's philosophy  - they replace parts of the STL and introduce their own type systems, both of which can cause serious compatibility issues. Also, https://www.thewindowsclub.com/directx-11-download-update-install[*DirectX*] libraries might limit your portability and don't align well with Boost's cross-platform goals.






[[isocommitteemeetings]]
== ISO C++ Committee Meetings

. *Who can attend ISO C++ Committee meetings?*
+
Members of https://www.incits.org/committees/pl22.16[PL22.16] (the INCITS/ANSI committee) or of https://www.open-std.org/jtc1/sc22/wg21/[JTC1/SC22/WG21 - The C++ Standards Committee - ISOCPP] member country committee (the "national body" in ISO-speak), can attend the meetings. You can also attend as a guest, or join in remotely through email. For details and contact information refer to https://isocpp.org/std/meetings-and-participation/[Meetings and Participation].
+
https://www.incits.org/[INCITS] has broadened PL22.16 membership requirements so anyone can join, regardless of nationality or employer, though there is a fee. Refer to https://www.incits.org/participation/apply-for-membership[Apply for Membership].
+
It is recommended that any non-member who would like to attend should check in with the https://www.incits.org/committees/pl22.16[PL22.16] chair or head of their national delegation. Boosters who are active on the committee can help smooth the way, so consider contacting the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost developers' mailing list] providing details of your interests.

. *When and where are the next meetings?*
+
There are three meetings a year. Two are usually in North America, and one is usually outside North America. See https://isocpp.org/std/meetings-and-participation/upcoming-meetings[Upcoming Meetings]. Detailed information about a particular meeting, including hotel information, is usually provided in a paper appearing in one of mailings for the prior meeting. If there isn't a link to it on the Meetings web page, you will have to go to the committee's https://www.open-std.org/jtc1/sc22/wg21/docs/papers/[C++ Standards Committee Papers] page and search a bit.

. *Is there a fee for attending meetings?*
+
No, but there can be a lot of incidental expenses like travel, lodging, and meals.

. *What is the schedule?*
+
The meetings typically start at 9:00AM on Monday, and 8:30AM other days. It is best to arrive a half-hour early to grab a good seat, some coffee, tea, or donuts, and to say hello to people.
+
Until the next standard ships most meetings are running through Saturday, although some end on Friday. The last day, the meeting is generally over much earlier than on other days. Because the last day's formal meeting is for formal votes only, it is primarily of interest only to actual committee members.
+
Sometimes there are evening technical sessions; the details aren't usually available until the Monday morning meeting. There may be a reception one evening, and, yes, significant others are invited. Again, details usually become available Monday morning.

. *What actually happens at the meetings?*
+
Monday morning an hour or two is spent in full committee on admin trivia, and then the committee breaks up into working groups (Core, Library, and Enhancements). The full committee also gets together later in the week to hear working group progress reports.
+
The working groups are where most technical activities take place. Each active issue that appears on an _issues list_ is discussed, as are papers from the mailing. Most issues are non-controversial and disposed of in a few minutes. Technical discussions are often led by long-term committee members, often referring to past decisions or longstanding working group practice. Sometimes a controversy erupts. It takes first-time attendees awhile to understand the discussions and how decisions are actually made. The working group chairperson moderates.
+
Sometimes straw polls are taken. In a straw poll anyone attending can vote, in contrast to the formal votes taken by the full committee, where only voting members can vote.
+
Lunch break is an hour and a half. Informal subgroups often lunch together; a lot of technical problems are discussed or actually solved at lunch, or later at dinner. In many ways these discussions involving only a few people are the most interesting. Sometimes during the regular meetings, a working group chair will break off a sub-group to tackle a difficult problem.

. *Do I have to stay at the venue hotel?*
+
No, and committee members on tight budgets often stay at other, cheaper, hotels. The venue hotels are usually chosen because they have large meeting rooms available, and thus tend to be pricey. The advantage of staying at the venue hotel is that it is then easier to participate in the off-line discussions, which can be at least as interesting as what actually happens in the scheduled meetings.

. *What do people wear at meetings?*
+
Programmer casual. No neckties to be seen.

. *What should I bring to a meeting?*
+
It is almost essential to have a laptop computer. There is a meeting wiki and there is internet connectivity. Wireless connectivity has become the norm.

. *What should I do to prepare for a meeting?*
+
It is helpful to have downloaded the mailing or individual papers for the meeting, and to have read any papers you are interested in. Familiarize yourself with the issues lists. Decide which of the working groups you want to attend.

. *What is a "Paper"?*
+
An electronic document containing issues, proposals, or anything else the committee is interested in. Very little gets discussed at a meeting, much less acted upon, unless it is presented in a paper. Papers are available to anyone. Papers don't just appear randomly; they become available four (lately six) times a year, before and after each meeting. Committee members often refer to a paper by saying what mailing it was in, for example: "See the pre-Redmond mailing."

. *What is a "Mailing"?*
+
A mailing is the set of papers prepared before and after each meeting, or between meetings. It is physically just a .zip or .gz archive of all the papers for a meeting. Although the mailing's archive file itself is only available to committee members and technical experts, the contents (except copies of the standard) are available to all as individual papers. The ways of ISO are inscrutable.

. *What is a "Reflector"?*
+
The committee's mailing lists are called "reflectors". There are a number of them; "all", "core", "lib", and "ext" are the main ones. As a courtesy, Boost technical experts can be added to committee reflectors at the request of a committee member.


== Libraries

. *What are smart pointers in Boost?*
+
Smart pointers are a feature of pass:[C++] that Boost provides in its boost:smart_ptr[] library. They are objects that manage the lifetime of other objects, automatically deleting the managed object when it is no longer needed. See the <<Smart Pointers>> section.

. *Does Boost provide a testing framework?*
+
Yes, boost:test[] is the unit testing framework provided by Boost. It includes tools for creating test cases, test suites, and for handling expected and unexpected exceptions. Refer to xref:testing-debugging.adoc[].

. *What is Boost.Asio?*
+
boost:asio[] is a library that provides support for _asynchronous_ input/output (I/O), a programming concept that allows operations to be executed without blocking the execution of the rest of the program.

. *What is Boost.MP11?*
+
boost:mp11[] (MetaProgramming Library for pass:[C++]11) is a Boost library designed to bring powerful metaprogramming capabilities to pass:[C++] programs. It includes a variety of templates that can be used to perform compile-time computations and manipulations. Refer to <<Metaprogramming>>.

. *Does Boost provide a library for threading?*
+
Yes, boost:thread[] provides a pass:[C++] interface for creating and managing threads, as well as primitives for synchronization and inter-thread communication. In addition, boost:atomic[] provides atomic operations and memory ordering primitives for working with shared data in multi-threaded environments. boost:lockfree[] provides lock-free data structures and algorithms for concurrent programming, allowing multiple threads to access shared data concurrently without explicit synchronization using locks or mutexes. For a lighter approach to multi-threading, consider boost:fiber[]. Fibers offer a high-level threading abstraction that allows developers to write asynchronous, non-blocking code with minimal overhead compared to traditional kernel threads. 

. *What is the Boost Spirit library?*
+
boost:spirit[] is a library for building recursive-descent parsers directly in pass:[C++]. It uses template metaprogramming techniques to generate parsing code at compile time. Refer to <<Metaprogramming>>.

. *I like algorithms, can you pique my interest with some Boost libraries that support complex algorithms?* 
+
Boost libraries offer a wide range of algorithmic and data structure support. Here are five libraries that you might find interesting:

+
* boost:graph[]: This library provides a way to represent and manipulate graphs. It includes algorithms for breadth-first search, depth-first search, https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm[Dijkstra's shortest paths], https://en.wikipedia.org/wiki/Kruskal%27s_algorithm[Kruskal's minimum spanning tree], and much more.

* boost:geometry[]: This library includes algorithms and data structures for working with geometric objects. It includes support for spatial indexing, geometric algorithms (like area calculation, distance calculation, intersections, etc.), and data structures to represent points, polygons, and other geometric objects.

* boost:multiprecision[]: If you need to perform computations with large or precise numbers, this library can help. It provides classes for arbitrary precision arithmetic, which can be much larger or more precise than the built-in types.

* boost:compute[]: This library provides a pass:[C++] interface to multi-core CPU and GPGPU (General Purpose GPU) computing platforms based on OpenCL. It includes algorithms for sorting, searching, and other operations, as well as containers like vectors and deques.

* boost:spirit[]: If you're interested in parsing or generating text, this library includes powerful tools based on formal grammar rules. It's great for building compilers, interpreters, or other tools that need to understand complex text formats.

. *I am tasked with building a real-time simulation of vehicles in pass:[C++]. What Boost libraries might give me the performance I need for real-time work, and support a simulation?*
+
Refer to xref:task-simulation.adoc[].


== Licensing 

. *What is the license for Boost libraries?*
+
Most Boost libraries are licensed under the xref:bsl.adoc[] (BSL), a permissive free software license that allows you to use, modify, and distribute the software under minimal restrictions. It is not a _requirement_ for a library to be licensed under the BSL, but its license must meet the xref:contributor-guide:ROOT:requirements/license-requirements.adoc[License Requirements]. Refer to the documentation or source code of any specific library to determine which license applies.

. *Can I use the Boost Logo, after I have built software using the Boost libraries, to help promote my product?*
+
Only with written permission from xref:contributor-guide:ROOT:oversight-committee.adoc[]. For full details refer to xref:contributor-guide:ROOT:docs/logo-policy-media-guide.adoc[].


== Metaprogramming

. *What is metaprogramming in the context of Boost pass:[C++]?*
+
Metaprogramming is a technique of programming that involves generating and manipulating programs. In the context of Boost and pass:[C++], metaprogramming often refers to _template metaprogramming_, which uses templates to perform computations at compile-time.

. *What is Boost.MP11?*
+
boost:mp11[] is a Boost library designed for metaprogramming using pass:[C++]11. It provides a set of templates and types for compile-time computations and manipulations, effectively extending the pass:[C++] template mechanism.

. *What can I achieve with Boost.MP11?*
+
With boost:mp11[], you can perform computations and logic at compile-time, thus reducing runtime overhead. For example, you can manipulate types, perform iterations, make decisions, and do other computations during the compilation phase.

. *What is a `typelist` and how can I use it with Boost.MP11?*
+
A `typelist` is a compile-time container of types. It's a fundamental concept in pass:[C++] template metaprogramming where operations are done at compile time rather than runtime, and types are manipulated in the same way that values are manipulated in regular programming.
+
In the context of the boost:mp11[] library, a `typelist` is a template class that takes a variadic list of type parameters. Here's an example:
+
[source,cpp]
----
#include <boost/mp11/list.hpp>

using my_typelist = boost::mp11::mp_list<int, float, double>;
----
+
In this example, `my_typelist` is a `typelist` containing the types `int`, `float`, and `double`. Once you have a `typelist`, you can manipulate it using the metaprogramming functions provided by the library. For example:
+
[source,cpp]
----
#include <boost/mp11/list.hpp>
#include <boost/mp11/algorithm.hpp>

using my_typelist = boost::mp11::mp_list<int, float, double>;

// Get the number of types in the list
constexpr std::size_t size = boost::mp11::mp_size<my_typelist>::value;

// Check if a type is in the list
constexpr bool contains_double = boost::mp11::mp_contains<my_typelist, double>::value;

// Add a type to the list
using extended_typelist = boost::mp11::mp_push_back<my_typelist, char>;

// Get the second type in the list
using second_type = boost::mp11::mp_at_c<my_typelist, 1>;
----
+
In these examples, `mp_size` is used to get the number of types in the list, `mp_contains` checks if a type is in the list, `mp_push_back` adds a type to the list, and `mp_at_c` retrieves a type at a specific index in the list. All these operations are done at compile time.

. *What are some limitations or challenges of metaprogramming with Boost.MP11?*
+
Metaprogramming with boost:mp11[] can lead to complex and difficult-to-understand code, especially for programmers unfamiliar with the technique. Compile errors can be particularly cryptic due to the way templates are processed. Additionally, heavy use of templates can lead to longer compile times.
+
Other challenges include lack of runtime flexibility, as decisions are made at compile time. And perhaps issues with portability can occur (say, between compilers) as metaprogramming pushes the boundaries of a computer language to its limits.

NOTE: boost:mp11[] supersedes the earlier boost:mpl[] and boost:preprocessor[] libraries.


== Modular Boost

. *What is meant by "Modular Boost"?*
+
Technically, Modular Boost consists of the Boost super-project and separate projects for each individual library in Boost. In terms of Git, the Boost super-project treats the individual libraries as submodules. Currently (early 2024) when the Boost libraries are downloaded and installed, the build organization does _not_ match the modular arrangement of the Git super-project. This is largely a legacy issue, and there are advantages to the build layout matching the super-project layout. This concept, and the effort behind it, is known as "Modular Boost".
+
Refer to the xref:contributor-guide:ROOT:superproject/overview.adoc[] topic (in the xref:contributor-guide:ROOT:index.adoc[]) for a full description of the super-project.

. *Will a Modular Boost affect the thrice-yearly Boost Release?*
+
No. The collection of libraries is still a single release, and there are no plans to change the release cadence.

. *Will this require that the current Boost source structure is changed?*
+
Yes. Unfortunately there is one restriction that adhering to a modular Boost requires - there can be no sub-libraries. That is, we can't support having libraries in the `root/libs/<group name>/<library>` format. All libraries must be single libraries under the `root/libs` directory. There's only a handful of libraries that currently do not conform to this already (notably the `root/libs/numeric/<name>` group of libraries).

. *Why do we want a Modular Boost?*
+
It's easier on everyone if we adopt a flat hierarchy. The user will experience a consistent process no matter which libraries they want to use. Similarly for contributors, the creation process will be consistent. Also, tools can be written that can parse and analyze libraries without an awkward range of exceptions. This includes tools written by Boost contributors. For example, the tools that are used to determine library dependencies. And any tool that a user might want to write for their own, or shared, use.

+
Other advantages of a modular format include:
+
* Users of Boost can now choose to include only the specific modules they need for their project, rather than downloading and building the entire Boost framework. This can significantly reduce the size of the codebase and dependencies in a project, leading to faster compilation times and reduced resource usage.
+
* Individual modules can be updated and released on their own schedule, independent of the rest of the libraries. This allows for quicker updates and bug fixes to individual libraries without waiting for a full release.
+
* The structure aligns well with package managers like https://conan.io/[Conan], https://vcpkg.io/en/[vcpkg], or https://bazel.build/about[Bazel], making it easier to manage Boost libraries within larger projects. Users can specify exactly which Boost libraries they need, and the package manager handles the inclusion and versioning.

. *Will the proposed changes be backwards-compatible from the user's perspective. In particular, the public header inclusion paths will still be <boost/numeric/<name>.hpp> rather than, say, <boost/numeric-conversion/<name>.hpp>, correct?*
+
Correct - backwards-compatibility should be maintained.

. *When will Modular Boost be available to users?*
+
An exact timeline requires issues to be resolved, though later in 2024 is the current plan-of-record.

== Numbers

. *Are there any Boost libraries that extend floating point precision, and at what cost?*
+
In pass:[C++], the precision of `float` and `double` types is determined by the IEEE 754 standard for floating-point arithmetic, which is used by nearly all modern compilers and hardware. A `float` (with 24 significant bits) is accurate to about 6 or 7 decimal places, a `double` (53 significant bits) to 15 to 17 decimal digits. A long double (80+ significant bits) extends this to 18 to 21 decimal digits. 
+
Boost does not replace these types, but extends your range of options using boost:multiprecision[]. There are the predefined types `cpp_dec_float_50` and `cpp_dec_float_100`, and the unlimited type `cpp_dec_float_<N>`, where you decide the value of N. `cpp_dec_float_50` would obviously give 50 digits, and `cpp_dec_float_201` gives 201 digits. For example:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <iostream>

using namespace boost::multiprecision;

int main() {
    cpp_dec_float_50 pi("3.14159265358979323846264338327950288419716939937510");
    auto result = pi * pi;

    // Set the precision slightly higher than the number of digits
    std::cout << std::setprecision(51) << result << std::endl;
}

----
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <iostream>

// Let's define a type to take pi to 200 decimal places, 201 including the initial "3"
using cpp_dec_float_201 = boost::multiprecision::number<boost::multiprecision::cpp_dec_float<201> >;

int main() {

    cpp_dec_float_201 pi("3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679"
        "8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196");

    std::cout << std::setprecision(201) << pi << std::endl;
}

----
+
boost:math[] adds high-quality special functions that integrate well with these types from boost:multiprecision[]. For example, `boost::math::gamma`, `boost::math::exp`, and `boost::math::lgamma` are available. Also, boost:qvm[] (quaternions, vectors, matrices) supports these custom precision types.
+
The cost as you can imagine is performance, the benefit is extreme accuracy. Under the hood, `cpp_dec_float<N>` stores `N` decimal digits of precision, using a base-10 representation, and uses an array of limbs to manage arbitrary-length mantissas.

. *Is there a Boost library that can help me with numbers like infinity, or the imaginary number that is the square root of -1?*
+
Yes, there is support for `infinity`, `NaN` (Not a Number), and imaginary numbers through different libraries. boost:math[] includes constants and utilities for working with `infinity` and `NaN`, which are part of IEEE 754 floating-point standards.
+
[source,cpp]
----
#include <boost/math/constants/constants.hpp>
#include <limits>
#include <iostream>
#include <cmath>

int main() {
    double inf = std::numeric_limits<double>::infinity();
    double nan = std::numeric_limits<double>::quiet_NaN();

    std::cout << "Infinity: " << inf << "\n";
    std::cout << "NaN: " << nan << "\n";

    // Or to test for them:
    if (std::isinf(inf)) std::cout << "This is infinity!\n";
    if (std::isnan(nan)) std::cout << "This is NaN!\n";

}

----
+
The complex functions of boost:math[] support imaginary numbers, such as the square root of -1.
+
[source,cpp]
----
#include <boost/math/complex.hpp>
#include <iostream>

int main() {
    std::complex<double> i(0.0, 1.0);
    std::complex<double> result = std::sqrt(std::complex<double>(-1.0, 0.0));

    std::cout << "sqrt(-1) = " << result << "\n"; // outputs (0,1)
}

----
+
boost:multiprecision[] supports high-precision complex types, for example:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/multiprecision/cpp_complex.hpp>

using namespace boost::multiprecision;
using complex50 = cpp_complex_50;

int main() {
    complex50 c(0, 1);
    auto r = sqrt(complex50(-1, 0));
    std::cout << r << "\n";  // (0,1)
}

----

. *Can Boost.Multiprecision help calcuate a huge number of prime numbers?*
+
Use the type `boost::multiprecision::cpp_int` to safely store large prime numbers beyond the capacity of the standard `int64_t`, and the core algorithm known as the _Sieve of Eratosthenes_:
+
[source,cpp]
----
#include <boost/multiprecision/cpp_int.hpp>
#include <iostream>
#include <vector>
#include <cmath>
#include <chrono>

using boost::multiprecision::cpp_int;

std::vector<cpp_int> generate_primes(size_t count) {
    // Rough upper bound for nth prime using approximation: n * log(n) * 1.2
    size_t estimate = static_cast<size_t>(count * std::log(count) * 1.2);
    std::vector<bool> is_prime(estimate + 1, true);
    std::vector<cpp_int> primes;

    is_prime[0] = is_prime[1] = false;

    for (size_t i = 2; i <= estimate && primes.size() < count; ++i) {
        if (is_prime[i]) {
            primes.emplace_back(i); // Store as cpp_int
            for (size_t j = i * 2; j <= estimate; j += i) {
                is_prime[j] = false;
            }
        }
    }

    return primes;
}

int main() {
    size_t prime_count = 100000; // adjust this to your needs (10 million may need 6+ GB of RAM)
    
    auto start = std::chrono::high_resolution_clock::now();
    std::vector<cpp_int> primes = generate_primes(prime_count);
    auto end = std::chrono::high_resolution_clock::now();

    std::chrono::duration<double> elapsed = end - start;
    std::cout << "Generated " << primes.size() << " primes.\n";
    std::cout << "Largest prime found: " << primes.back() << "\n";
    std::cout << "Time elapsed: " << elapsed.count() << " seconds.\n";

    return 0;
}

----
+
Running this code:
+
[source,text]
----
Generated 100000 primes.
Largest prime found: 1299709
Time elapsed: 1.86556 seconds.

----

Note:: `cpp_int` is overkill for small primes, but essential if you're working with large ones, such as 512-bit cryptographic primes.

. *Am I right that Boost libraries do not improve on the performance of the standard floating point `double`?*
+
Correct. Use `double` if you can, and only use higher precision types when you're accumulating billions of values and errors grow unbounded, or you need more than 17 digits of accuracy, or you're solving numerically unstable equations, or you're doing astronomy, cryptography, quantum physics, symbolic algebra, or working with scientific constants.

Note:: A _numerically unstable equation_ is one in which small changes or errors in input, or intermediate calculations, can lead to large errors in the final result due to the amplification of rounding or truncation errors in floating-point arithmetic. Numerical instability often arises when subtracting two nearly equal numbers (called _catastrophic cancellation_), dividing by very small numbers, performing many iterations where small errors accumulate, and poor choice of algorithm. A catastrophic cancellation might occur when subtracting 1.0000001 from 1.0000002 - precision and rounding errors might distort the result. Stable algorithms preserve significant digits and give reliable results even with floating-point limits.

. *What scientific numbers, similar to pi, require precision beyond that provided by the standard `double`?*
+
Here is a table of the usual suspects:
+
[cols="2,1,3",options="header",stripes=even,frame=none]
|===
| *Constant* | *Typical Digits Needed* | *Why `double` Isn't Enough*
| π (pi) | 50-100+ | Needed with extreme accuracy in orbital mechanics, quantum computing, etc.
| e (Euler's number) | 30-100+ | Used in high-precision financial models, calculus, and exponential growth systems.
| γ (Euler-Mascheroni constant) | 50-100+ | Arises in analytic number theory and integrals.
| φ (Golden ratio) | 30+ | Used in precise design and algorithmic ratios.
| Planck's constant (h) | 25-100 | Central to quantum mechanics; precise modeling demands high precision.
| Fine-structure constant (α) | 30-80 | Key in atomic physics and fundamental interactions.
| Avogadro's number | 23+ | Often stored as a float, but high-accuracy simulations may demand higher precision.
| Speed of light (c) | 17+ | For ultra-precise relativistic calculations.
| Gravitational constant (G) | 20-100 | Known only to limited digits experimentally, but simulations may push precision.
| Riemann zeta constants | 30-200+ | Arise in number theory and string theory.
| Catalan's constant | 50+ | Appears in combinatorics and integrals.
| Apéry's constant | 50-200 | Arises in irrationality proofs and advanced analysis.
|===

Note:: Precision can become an obsession. Pi has been computed to over 100 trillion digits, but NASA's orbital calculations use only around the first 15 digits of pi (so a `double` would work!).

. *To avoid floating point numbers altogether, I could use fractions. For example, storing a third as 1 over 3 avoids using 0.33333 ad infinitum. Is there a Boost library that would make sense of numbers stored only as integer fractions?*
+
Yes. boost:rational[] is a library designed specifically to represent and manipulate rational numbers — that is, numbers stored as fractions of two integers (such as, 1/3, 355/113).
+
It avoids floating-point approximation entirely, preserving mathematical exactness throughout arithmetic operations. The library automatically normalizes (reduces) fractions - so 3/6 would be reduced to 1/2. And it can interoperate with `int`, `long`, or even `boost::multiprecision::cpp_int`. For example:
+
[source,cpp]
----
#include <boost/rational.hpp>
#include <iostream>

int main() {
    boost::rational<int> a(1, 3);  // 1/3
    boost::rational<int> b(2, 5);  // 2/5

    auto sum = a + b;              // 1/3 + 2/5 = 11/15
    auto product = a * b;          // 1/3 * 2/5 = 2/15

    std::cout << "Sum: " << sum.numerator() << "/" << sum.denominator() << "\n";
    std::cout << "Product: " << product << "\n";  // prints as 2/15

    // Comparison
    if (a < b)
        std::cout << "a is less than b\n";
}

----

Note:: Using rational numbers there is a risk of integer overflow, so consider using large integers for inputs (`boost::multiprecision::cpp_int` or similar), and this approach is not ideal for numbers known to be irrational (square root of 2, and the scientific constants listed above).

. *Can I use Boost.Multiprecision or Boost.Math to help with my project on RSA public-key encryption?*
+
Yes. Starting with the basic algorithm for RSA (Rivest-Shamir-Adleman - the authors of the algorithm) which follows these steps:
+
.. Choose two large prime numbers `p` and `q`
.. Compute `n = p * q`
.. Compute Euler's totient `ϕ(n) = (p-1)(q-1)`
.. Choose public exponent `e` such that `1 < e < ϕ(n)` and `gcd(e,ϕ(n)) = 1`
.. Compute private exponent `d` such that `e⋅d ≡ 1 mod ϕ(n)`
.. Now you have: `public-key = (e,n)` and `private-key = (d,n)`
+
We can now use `cpp_int` from boost:multiprecision[] to handle arbitrary-precision integers. And, if need be, you can use `is_prime` from boost:math[] for primality checks on larger randomly generated values (which you may want to add at a later date, using boost:random[]).
+
[source,cpp]
----
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/integer/common_factor_rt.hpp>
#include <iostream>

using namespace boost::multiprecision;

// Compute modular inverse of a modulo m using Extended Euclidean Algorithm
cpp_int modinv(cpp_int a, cpp_int m) {
    cpp_int m0 = m, t, q;
    cpp_int x0 = 0, x1 = 1;

    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m;
        a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }

    return (x1 < 0) ? x1 + m0 : x1;
}

int main() {
    // Small primes for demo
    cpp_int p = 61;
    cpp_int q = 53;

    cpp_int n = p * q;                     // n = 3233
    cpp_int phi = (p - 1) * (q - 1);       // φ(n) = 3120

    cpp_int e = 17; // Common public exponent
    cpp_int d = modinv(e, phi);            // Compute private key

    // Display keys
    std::cout << "Public Key (e, n): (" << e << ", " << n << ")\n";
    std::cout << "Private Key (d, n): (" << d << ", " << n << ")\n";

    // Create message
    cpp_int message = 65;
    std::cout << "Initial message: " << message << "\n";

    // Encrypt message
    cpp_int encrypted = powm(message, e, n); // m^e mod n
    std::cout << "Encrypted message: " << encrypted << "\n";

    // Decrypt message
    cpp_int decrypted = powm(encrypted, d, n); // c^d mod n
    std::cout << "Decrypted message: " << decrypted << "\n";

    return 0;
}

----

Note:: Consider using `independent_bits_engine` from boost:random[] for a clean way to get large random integers of fixed bit-width, and then consider very large prime numbers of perhaps 1024 bits.

. *What does a 1024-bit prime number look like?*
+
Here is one:
+
[source,cpp]
----
cpp_int prime = 165918700393058288029118516503856682928352034064210292320510526037152431960844672521054555721941412725769027652540094762345484278576411078143188748708281181119556988860248537167684663864334811189453410905241474311369868568296877192226227785240656833746573473244854528133231976802973699288063056142727481235873

----

. *I need efficient memory storage for a real-time simulation. The use case is small counts, for example the number of carrier task forces operating in one ocean at any one time - a number which will never exceed 10 let alone 256?*
+
A full sized int or even a byte is comically oversized for this use case. You could use the standard: `std::uint8_t num_groups;`, however you might like to add some range-safety. Consider the following code as it's memory footprint is exacty 3 bytes:
+
[source,cpp]
----
#include <cstdint>
#include <boost/endian/arithmetic.hpp>
#include <boost/numeric/conversion/cast.hpp>

struct OceanStatus {
    boost::endian::little_uint8_t carrier_groups; // 1 byte on disk
    boost::endian::little_uint8_t submarine_groups;
    boost::endian::little_uint8_t air_wings;

    void set_carrier_groups(int x) {

        // Guarantee 0–10 range at runtime
        if (x < 0 || x > 10)
            throw std::out_of_range("carrier group count must be 0-10");

        // Safe cast to uint8_t
        carrier_groups = boost::numeric_cast<std::uint8_t>(x);
    }
};

----

. *What library should I look at to help pack really small integers (say 2 to 4 bits each) into the minimum number of bytes possible?*
+
The libary to evaluate is boost:dynamic-bitset[], it gives you stable bit indexing, easy clearing/writing slices, guaranteed predictable ordering, and portability across CPU architectures. In particular, check out the function `to_block_range` for exporting packed blocks. This should be easier - and safer - than hand-rolling your own masks and shifts.

== Other Languages

. *Have developers written applications in languages such as Python that have successfully used the Boost libraries?*
+
Yes, developers have successfully used Boost libraries in applications written in languages other than pass:[C++] by leveraging language interoperability features and creating bindings or wrappers.
+
The most notable example is the use of boost:python[], a library specifically designed to enable seamless interoperability between pass:[C++] and Python. boost:python[] allows developers to expose pass:[C++] classes, functions, and objects to Python, enabling the use of the libraries from Python code. This has been used extensively in scientific computing, game development, and other fields where the performance of pass:[C++] is combined with the ease of Python.

. *What real world applications have combined Python with the Boost libraries?*
+
Here are some examples:
+
* https://www.blender.org/[Blender] is a widely-used open-source 3D creation suite. It supports the entirety of the 3D pipeline, including modeling, rigging, animation, simulation, rendering, compositing, and motion tracking. Blender uses Boost libraries for various purposes, including memory management, string manipulation, and other utility functions. Blender's Python API, which allows users to script and automate tasks, integrates with pass:[C++] code using boost:python[].
+
* https://pytorch.org/[PyTorch] is an open-source machine learning library based on the Torch library. It is used for applications such as natural language processing and computer vision. PyTorch uses several Boost libraries to handle low-level operations efficiently. boost:python[] is used to create bindings between pass:[C++] and Python, allowing PyTorch to provide a seamless interface for Python developers.
+
* https://opencv.org/[OpenCV] (Open Source Computer Vision Library) is an open-source computer vision and machine learning software library. OpenCV's Python bindings use boost:python[] to interface between the pass:[C++] core and Python. This allows Python developers to use OpenCV's powerful pass:[C++] functions with Python syntax.
+
* https://docs.enthought.com/canopy/2.1/index.html[Enthought Canopy] is a comprehensive Python analysis environment and distribution for scientific and analytic computing. It includes a Python distribution, an integrated development environment (IDE), and many additional tools and libraries.

. *Are there some solid examples of real world applications that have combined C# with the Boost libraries?*
+
Here are some great examples:
+ 
* In the world of game development, several projects use pass:[C++] for performance-critical components and C# for scripting and higher-level logic. The Boost libraries are often used in the pass:[C++] components, in particular to leverage their algorithms, and data structures. https://unity.com/[Unity] allows the use of native plugins written in pass[C++]. These plugins can use Boost libraries for various functionalities, such as pathfinding algorithms or custom data structures, and then be called from C# scripts within Unity.
+
* Financial applications often require high performance and reliability. They may use pass:[C++] for core processing and Boost libraries for tasks like date-time calculations, serialization, and multithreading. C# is used for GUI and integration with other enterprise systems. Trading platforms and risk management systems sometimes use Boost libraries for backend processing and interoperate with C# components for the user interface and data reporting.
+
* Scientific computing applications that need high-performance computation often use pass:[C++] for core algorithms. C# is great for visualization, user interaction, and orchestration. Computational chemistry and physics applications sometimes use Boost for numerical computations and data handling, while C# provides the tools for managing simulations and visualizing results.

. *Can I see some sample code of how to wrap Boost functions to be available for use in a C# app?*
+
The following code shows how to create a wrapper for a pass:[C++] class that uses Boost, and then calls this class from a C# application. The handling of return values and exceptions are shown too. All the class does is convert a string to upper case.
+ 
_The following code was written and tested using Visual Studio 2022, with Boost version 1.88. Visual Studio has been installed with tools to create both native pass:[C++] and .NET C# apps._
+
In Visual Studio, create a pass:[C++] *Dynamic Link Library (DLL)* project, `MyDLL`, and in the project properties make sure the *Additional Include Directories* has the path to your Boost `include` files, and *Additional Library Directories* has the path to your Boost `lib` files. Most importantly in the *Configuration Properties/Advanced* section, make sure the *Common Language Runtime Support* setting is *.NET Framework Runtime Support (/clr)*. Delete the default `dllmain.cpp` file.
+
Create a header file, `MyClass.h`, and copy in the following code:
+
[source,cpp]
----
#pragma once
#include <string>

class MyClass {
public:
    std::string to_upper(const std::string& input);
};

----
+
Create a second header file, `MyClassWrapper.h`, and copy in:
+
[source,cpp]
----
#pragma once

#include "MyClass.h"

using namespace System;

public ref class MyClassWrapper {
private:
    MyClass* instance;

public:
    MyClassWrapper();
    ~MyClassWrapper();
    !MyClassWrapper();

    String^ ToUpper(String^ input);
};

----
+
Create a new source file, `MyClass.cpp`, and copy in:
+
[source,cpp]
----
#include "pch.h"
#include "MyClass.h"
#include <boost/algorithm/string.hpp>
#include <stdexcept>

std::string MyClass::to_upper(const std::string& input) {
    if (input.empty()) {
        throw std::runtime_error("Input string is empty");
    }
    return boost::to_upper_copy(input);
}

----
+
We use boost:algorithm[] here, to show how to engage our libraries.
+
Next, create a second source file, `MyClassWrapper.cpp`, to expose the class to .NET:
+
[source,cpp]
----
#include "pch.h"
#include "MyClassWrapper.h"
#include <msclr/marshal_cppstd.h>
#include <stdexcept>

using namespace msclr::interop;
using namespace System::Runtime::InteropServices;

MyClassWrapper::MyClassWrapper() {
    instance = new MyClass();
}

MyClassWrapper::~MyClassWrapper() {
    this->!MyClassWrapper();
}

MyClassWrapper::!MyClassWrapper() {
    delete instance;
}

String^ MyClassWrapper::ToUpper(String^ input) {
    try {
        std::string nativeInput = marshal_as<std::string>(input);
        std::string result = instance->to_upper(nativeInput);
        return gcnew String(result.c_str());
    }
    catch (const std::exception& e) {
        throw gcnew ExternalException(gcnew String(e.what()));
    }
}
----
+
Now, build your DLL, and hopefully it will build correctly. If it does, close that solution. Errors are usually because of missing components, rather than faulty code.
+
Now create the C# application that uses the wrapper. In Visual Studio, create a C# Console app, `CppCsharp`, noting that a .NET framework is part of the project, and overwrite the default with the following code.
+
[source,csharp]
----
using System;

class Program
{
    static void Main()
    {
        MyClassWrapper myClass = new MyClassWrapper();

        try
        {
            string result = myClass.ToUpper("hello world");
            Console.WriteLine("Result: " + result);

            // Test with an empty string to trigger the exception
            result = myClass.ToUpper("");
            Console.WriteLine("Result: " + result);

        }
        catch (System.Runtime.InteropServices.ExternalException e)
        {
            Console.WriteLine("Caught an exception: " + e.Message);
        }
    }
}
----
+
You will notice that the `MyClassWrapper` declaration is marked as erroneous.
+
In Visual Studio, in the *Project* menu, select *Add Project Reference*, and then use the *Browse* option to locate your `MyDLL.dll`. You should notice the error marks disappear.
+
Run the program, noting the initial string is converted to upper case, and the second call correctly returns the exception:
+
----
Result: HELLO WORLD
Caught an exception: Input string is empty
----

. *Does the Java Native Interface (JNI) work with the Boost libraries?*
+
Through the use of the Java Native Interface (JNI) or Java Native Access (JNA), developers can call Boost libraries from Java applications. It involves creating native methods in Java that are implemented in pass:[C++] and using Boost libraries as part of those implementations.

Note:: Similar techniques can be applied to other languages, such as R, Ruby, Perl, and Lua, using their respective foreign function interfaces (FFI) or binding libraries. 

. *What is the industry consensus for the expected remaining lifespan for pass:[C++], and does any other language look like it might become the replacement for it?*
+
The expected remaining lifespan of the pass:[C++] programming language is generally considered to be long, probably spanning several decades. While it's difficult to assign a precise number of years, here's an overview of the factors contributing to this consensus:
+
* pass:[C++] is deeply embedded in many critical systems, including operating systems, game engines, real-time systems, financial systems, and large-scale infrastructure projects. The massive amount of existing code ensures that the language will be relevant for a long time as maintaining, updating, and interacting with this codebase will remain necessary.
* The Boost libraries and the pass:[C++] Standard place a strong emphasis on backward compatibility, which helps ensure that older code continues to work with new versions of the language.
* The pass:[C++] language continues to evolve, with regular updates to the standard (for example, pass:[C++]11, pass:[C++]14, pass:[C++]17, pass:[C++]20, and pass:[C++]23). These updates introduce new features and improvements that keep the language modern and competitive.
* The pass:[C++] community, including the ISO pass:[C++] committee and Boost users, are highly active, ensuring that the language adapts to new programming paradigms, hardware architectures, and developer needs.
* High Performance - pass:[C++] remains one of the go-to languages for applications where performance is critical, such as gaming, high-frequency trading, and embedded systems. Its ability to provide low-level memory and hardware control while still supporting high-level abstractions makes it difficult to replace.
* For system-level programming and scenarios where fine-grained control over system resources is necessary, pass:[C++] is still unmatched.
* pass:[C++] is still widely taught in universities, especially in courses related to systems programming, algorithms, and data structures. As a teaching language, it instills principles of memory management, performance optimization, and object-oriented programming, which are valuable across many programming domains.
* pass:[C++] has a strong presence in specialized domains such as aerospace, robotics, telecommunications, and automotive software, where reliability, real-time performance, and low-level hardware access are critical. For example, some current EV manufacturers are using pass:[C++] and Unreal Engine to develop their in-car infotainment and control systems.
* While newer languages may rise in popularity for certain use cases, no other language currently offers the same combination of performance, control, and ecosystem that pass:[C++] provides, making it unlikely to be replaced any time soon.
+
Future technological shifts, such as advances in quantum computing or entirely new programming paradigms, could influence (increase or decrease) the lifespan of pass:[C++]. However, given its adaptability and entrenched role in many industries, pass:[C++] is expected to evolve alongside these changes rather than be replaced by them.

. *If I was to learn one other language, in addition to pass:[C++], what should it be to best prepare myself for an uncertain future?*
+
Python is often the top recommendation due to its versatility, simplicity, and wide application in growing fields like artificial intelligence (AI), machine learning (ML), rapid prototyping, and data science. And boost:python[] is there to help you integrate with the Boost libraries. Rust is another strong contender, especially if you are interested in systems programming and are looking for reliability and security. If you see the future as more cloud computing, then Go makes a strong case for itself.  And let's not forget that so much computing is now web based, so JavaScript deserves a mention here too. All of these languages offer valuable resources that complement pass:[C++] and prepare you for an uncertain future.

== Production and Debug Builds

. *What is the value of using `BOOST_ASSERT` or `BOOST_STATIC_ASSERT` over the Standard Library assert macros?*
+
There are a few advantages of using the Boost asserts, available in `<boost/assert.hpp>`, including that `BOOST_ASSERT` is fully customizable using `BOOST_ENABLE_ASSERT_HANDLER`, which can be used to log extra data or stack traces, and there is better integration with boost:test[]. `BOOST_STATIC_ASSERT` is best utilized when using older pass:[C++] standards (pre-pass:[C++17]), or you are using deeply templated code. You might also prefer the Boost macros if you are engaging the features of other Boost libraries and are looking for consistent tooling. For a fuller discussion, refer to xref:boost-macros.adoc[].

. *For maximum performance, is it good practice to remove, or comment out, the `BOOST_ASSERT`s for the final production code, or do they simply not get compiled into anything so there is no performance cost for leaving them as is?*
+
By default, `BOOST_ASSERT` macros are completely removed from the compiled binary when `NDEBUG` is defined, just like the standard assert macro. If `NDEBUG` is not defined a `BOOST_ASSERT(x)` will expand, usually to an `assertion_failed()` if the assert condition fails. If NDEBUG is defined it expands to `((void)0)` so nothing is generated. Boost does provide the `BOOST_DISABLE_ASSERTS` macro, which has the same effect on Boost asserts as `NDEBUG` - but will leave other asserts alone.

. *What is usually considered to be best practices in handling assertions that fire with a production build?*
+
Instead of throwing an exception when an assert fails, it is often the best practice to log the failure. For example, here is a custom assert handler using the features of boost:log[] to record the event:
+
[source,cpp]
----
#include <boost/assert.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/expressions.hpp>
#include <sstream>
#include <cstdlib>

namespace logging = boost::log;

// Configure Boost.Log (call once at startup)
void init_logging() {
    logging::add_common_attributes();

    // Console output
    logging::add_console_log(
        std::clog,
        logging::keywords::format = "[%TimeStamp%] [%Severity%] %Message%"
    );

    // File output
    logging::add_file_log(
        logging::keywords::file_name = "assert_failures_%N.log",
        logging::keywords::rotation_size = 10 * 1024 * 1024, // 10 MB
        logging::keywords::format = "[%TimeStamp%] [%Severity%] %Message%"
    );
}

// Custom handler for BOOST_ASSERT
namespace boost {
    void assertion_failed(char const* expr, char const* function, char const* file, long line) {
        std::ostringstream oss;
        oss << "BOOST_ASSERT failed!\n"
            << "  Expression: " << expr << "\n"
            << "  Function:   " << function << "\n"
            << "  File:       " << file << "\n"
            << "  Line:       " << line;

        BOOST_LOG_TRIVIAL(error) << oss.str();

        std::abort(); // Optional: comment out if soft fail is desired
    }
}

----
+
An example use of this handler would be:
+
[source,cpp]
----
#include <boost/assert.hpp>
#include <iostream>

// Declare logging initializer
void init_logging();

void test_logic(int value) {
    BOOST_ASSERT(value >= 0);
    std::cout << "Value is: " << value << std::endl;
}

int main() {
    init_logging();

    std::cout << "Testing BOOST_ASSERT with value = 42..." << std::endl;
    test_logic(42);

    std::cout << "Testing BOOST_ASSERT with value = -1..." << std::endl;
    test_logic(-1); // Logs to file and console, then aborts

    return 0;
}

----

. *What should I be aware of when moving from a Debug to a Production release?*
+
Use this checklist to ensure your application correctly integrates Boost libraries across **Debug** and **Release** configurations.
+
- *Linking and Compatibility*
- [ ] Link with the correct Boost library variant (`-gd` for Debug, none for Release).
- [ ] Ensure runtime settings (Debug CRT or Release CRT) match Boost binaries.
- [ ] Avoid mixing Debug-built Boost libraries with Release-built applications.
- *Macro Definitions and Configuration*
- [ ] Define `BOOST_DEBUG` in Debug builds to enable extra runtime checks (if applicable).
- [ ] Define `BOOST_DISABLE_ASSERTS` in Release builds to remove `BOOST_ASSERT` checks.
- [ ] Optionally define `BOOST_ENABLE_ASSERT_HANDLER` to install custom assertion handlers.
- [ ] Review conditional macros like `BOOST_NO_EXCEPTIONS`, `BOOST_NO_RTTI`, etc.
- *Assertions and Diagnostics*
- [ ] Use `BOOST_ASSERT` for critical development-time checks.
- [ ] Consider diagnostic logging using `BOOST_LOG_TRIVIAL`.
- [ ] Ensure failing assertions are tested and logged in Debug builds.
- *Debugging and Tooling*
- [ ] Run AddressSanitizer, Valgrind, or Visual Leak Detector in Debug builds. Refer to xref:contributor-guide:ROOT:testing/sanitizers.adoc[Contributor Guide: Sanitizers].
- [ ] Confirm boost:pool[], boost:container[], and alloc-heavy libraries don't leak memory.
- [ ] Validate boost:thread[], boost:asio[], and boost:fiber[] components using thread sanitizers.
- *Performance Awareness*
- [ ] Avoid benchmarking with Debug builds — optimization is disabled.
- [ ] Use Release builds to test compile times for boost:mp11[], boost:spirit[], and any heavy use of templates.
- [ ] Validate any `BOOST_FORCEINLINE` or `BOOST_NOINLINE` effects in both builds.
- *Unit Testing*
- [ ] Run the full suite of unit tests in both Debug and Release.
- [ ] Ensure no logic is only covered by Debug-only paths or assertions.
- [ ] Use boost:test[] to validate results across optimization levels.

. *Typically, how should I set up a CMake file to handle Debug and Release builds?*
+
Here's an example of how to set up your `CMakeLists.txt` to handle `BOOST_ASSERT` correctly by toggling behavior based on the build type (Debug or Release). The example includes linking with some sample libraries (boost:log[], boost:system[] and boost:thread[]):
+
[source,cmake]
----
cmake_minimum_required(VERSION 3.10)
project(MyBoostApp)

# Set your C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Enable debug symbols for Debug mode
set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g")

# Link Boost (adjust components as needed)
find_package(Boost REQUIRED COMPONENTS log log_setup system thread)

target_link_libraries(MyBoostApp PRIVATE
    Boost::log
    Boost::log_setup
    Boost::system
    Boost::thread
)

add_executable(MyBoostApp main.cpp)

target_include_directories(MyBoostApp PRIVATE ${Boost_INCLUDE_DIRS})
target_link_libraries(MyBoostApp PRIVATE ${Boost_LIBRARIES})

# Enable BOOST_ASSERT in Debug, disable in Release
target_compile_definitions(MyBoostApp PRIVATE
    $<$<CONFIG:Debug>:BOOST_ENABLE_ASSERT_HANDLER>
    $<$<CONFIG:Release>:NDEBUG>
)

# Optional: You can define a custom assert handler in debug builds
# by linking a file like the assert handler shown above that defines `boost::assertion_failed`

----

== Reflection

. *Is there a native library or system that approximates the capabilities of .NET System.Reflection?*
+
Reflection in .NET is the ability of a program to inspect and manipulate its own structure and metadata at runtime. Think of reflection as a runtime mirror — it lets a program look at itself and act accordingly. Boost does not have a full runtime reflection system like .NET's System.Reflection, but it does include several libraries and utilities that provide partial or compile-time reflection capabilities — the kind that are most practical and efficient in pass:[C++]. The closest Boost comes to real reflection is encapsualted in boost:describe[]. This library allows you to describe the structure of a class — its members, base classes, and enums — at compile time, so you can iterate over them generically. Internally, boost:describe[] uses the features of boost:mp11[].
+
Other libraries that you might find value in include boost:pfr[] (_Precise Function Reflection_), which lets you reflect on structure fields without macros or metadata, using clever template magic. For richer type information there is boost:type_index[] and boost:callable_traits[], and for metaprogramming there is boost:mp11[], boost:fusion[], and boost:hana[].

. *Are there plans to extend Reflection further into Boost or the Standard C++ Library?*
+
The short answer is yes, into the Standard, but not yet. There are some niggling downsides to enabling full reflection, including slower than normal code, more difficult code maintenance and debugging, and string related issues (as string names are relied on). The standard work is known as the Reflection TS (_Technical Specification_).

. *Can you show me example code demonstrating how to use Boost.Describe for Reflection?*
+
The following example shows how boost:describe[] and boost:mp11[] work together to achieve something close to automatic runtime reflection:
+
[source,cpp]
----
#include <boost/describe.hpp>
#include <boost/mp11.hpp>
#include <iostream>


// Describe a simple struct
struct User {
    int id;
    std::string name;
};

// Generate reflection metadata
BOOST_DESCRIBE_STRUCT(User, (), (id, name))

// Print fields using Boost.MP11 iteration
template <typename T>
void print_fields(const T& obj) {
    boost::mp11::mp_for_each<boost::describe::describe_members<T, boost::describe::mod_public>>(
        [&](auto D) {
            std::cout << D.name << " = " << obj.*D.pointer << "\n";
        });
}

int main() {
    User u{ 42, "Ada" };
    print_fields(u);
}
----

. *Can you show me example code demonstrating how to use Boost.PFR for Reflection?*
+
boost:pfr[] provides the `io` function for automatic input/output stream operators (`<<` and `>>`) for aggregate types — meaning you can print or read structs directly without manually defining stream operators. It reflects all public fields of a type at compile time (without macros or boilerplate), producing readable output like {field1, field2, field3} automatically, for example:
+
[source,cpp]
----
#include <boost/pfr.hpp>
#include <iostream>

struct User {
    int id;
    std::string name;
    double balance;
};

int main() {
    User u{ 42, "Alice", 100.5 };

    std::cout << "As tuple: " << boost::pfr::io(u) << "\n";
}
----

== Releases

. *How do I download the latest libraries?*
+
Go to https://www.boost.org/users/download/[Boost Downloads].

. *What do the Boost version numbers mean?*
+
The scheme is x.y.z, where x is incremented only for massive changes, such as a reorganization of many libraries, y is incremented whenever a new library is added, and z is incremented for maintenance releases. y and z are reset to 0 if the value to the left changes

. *Is there a formal relationship between Boost.org and the pass:[C++] Standards Committee?*
+
No, although there is a strong informal relationship in that many members of the committee participate in Boost, and the people who started Boost were all committee members.

. *Will the Boost.org libraries become part of the next pass:[C++] Standard?*
+
Some might, but that is up to the standards committee. Committee members who also participate in Boost will definitely be proposing at least some Boost libraries for standardization. Libraries which are "existing practice" are most likely to be accepted by the C++ committee for future standardization. Having a library accepted by Boost is one way to establish existing practice.

. *Is the Boost web site a commercial business?*
+
No. It is a non-profit.

. *Why do Boost headers have a .hpp suffix rather than .h or none at all?*
+
File extensions communicate the "type" of the file, both to humans and to computer programs. The '.h' extension is used for C header files, and therefore communicates the wrong thing about pass:[C++] header files. Using no extension communicates nothing and forces inspection of file contents to determine type. Using `.hpp` unambiguously identifies it as pass:[C++] header file, and works well in practice.

. *How do I contribute a library?*
+
Refer to the xref:contributor-guide:ROOT:index.adoc[]. Note that shareware libraries, commercial libraries, or libraries requiring restrictive licensing are all not acceptable. Your library must be provided free, with full source code, and have an acceptable license. There are other ways of contributing too, providing feedback, testing, submitting suggestions for new features and bug fixes, for example. There are no fees for submitting a library.

== Safe C++

. *I use Boost Libraries in my current projects. What do I need to know about Safe pass:[C++]?*
+
Retrofitting the pass:[C++] language with memory-safe constructs has proven to be daunting. The https://safecpp.org/P3390R0.html[Safe pass:[C++]] proposal for a memory-safe set of operations is currently in a state of indefinite hiatus. For more information, including current safe coding practices, refer to xref:contributor-guide:ROOT:contributors-faq#safecpp[Contributors FAQ: Safe pass:[C++]]. For terminology - refer to xref:glossary.adoc#s[Glossary: S].

== Smart Pointers

. *What different types of smart pointers are there?*
+
The boost:smart_ptr[] library provides a set of smart pointers that helps in automatic and appropriate resource management. They are particularly useful for managing memory and provide a safer and more efficient way of handling dynamically allocated memory. The library provides the following types of smart pointers:
+
[disc]
* `boost::scoped_ptr`: A simple smart pointer for sole ownership of single objects that must be deleted. It's neither copyable nor movable. Deletion occurs automatically when the `scoped_ptr` goes out of scope.

* `boost::scoped_array`: Similar to `scoped_ptr`, but for arrays instead of single objects. Deletion occurs automatically when the `scoped_array` goes out of scope.

* `boost::shared_ptr`: A reference-counted smart pointer for single objects or arrays, which automatically deletes the object when the reference count reaches zero. Multiple `shared_ptr` can point to the same object, and the object is deleted when the last `shared_ptr` referencing it is destroyed.

* `boost::shared_array`: Similar to `shared_ptr`, but for arrays instead of single objects.

* `boost::weak_ptr`: A companion to `shared_ptr` that holds a non-owning ("weak") reference to an object that is managed by `shared_ptr`. It must be converted to `shared_ptr` in order to access the referenced object.

* `boost::intrusive_ptr`: A smart pointer that uses intrusive reference counting. Intrusive reference counting relies on the object to maintain the reference count, rather than the smart pointer. This can provide performance benefits in certain situations, but it requires additional support from the referenced objects.

* `boost::enable_shared_from_this`: Provides member function `shared_from_this`, which enables an object that's already managed by a `shared_ptr` to safely generate more `shared_ptr` instances that all share ownership of the same object.

* `boost::unique_ptr`: A smart pointer that retains exclusive ownership of an object through a pointer. It's similar to `std::unique_ptr` in the pass:[C++] Standard Library.

. *Can you give me a brief coding overview of how to use smart pointers efficiently?*
+
There are several types of smart pointers with different characteristics and use cases, so use them appropriately according to your program's requirements. Here are some common examples:

+
A `shared_ptr` is a reference-counting smart pointer, meaning it retains shared ownership of an object through a pointer. When the last `shared_ptr` to an object is destroyed, the pointed-to object is automatically deleted. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp(new int(10));
    // Now 'sp' owns the 'int'.
    // When 'sp' is destroyed, the 'int' will be deleted.
}
----
+
Note that `shared_ptr` objects can be copied, meaning ownership of the memory can be shared among multiple pointers. The memory will be freed when the last remaining `shared_ptr` is destroyed. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp1(new int(10));
    // Now 'sp1' owns the 'int'.
    boost::shared_ptr<int> sp2 = sp1;
    // Now 'sp1' and 'sp2' both own the same 'int'.
    // The 'int' will not be deleted until both 'sp1' and 'sp2' are destroyed.
}
----
+
A `weak_ptr` is a smart pointer that holds a non-owning ("weak") reference to an object managed by a `shared_ptr`. It must be converted to `shared_ptr` in order to access the object. For example:
+
[source,cpp]
----
#include <boost/shared_ptr.hpp>
#include <boost/weak_ptr.hpp>

void foo() {
    boost::shared_ptr<int> sp(new int(10));
    boost::weak_ptr<int> wp = sp;
    // 'wp' is a weak pointer to the 'int'.
    // If 'sp' is destroyed, 'wp' will be able to detect it.
}
----
+
A `unique_ptr` is a smart pointer that retains exclusive ownership of an object through a pointer. It's similar to `std::unique_ptr` in the pass:[C++] Standard Library. For example:
+
[source,cpp]
----
#include <boost/interprocess/smart_ptr/unique_ptr.hpp>

void foo() {
    boost::movelib::unique_ptr<int> up(new int(10));
    // Now 'up' owns the 'int'.
    // When 'up' is destroyed, the 'int' will be deleted.
}
----


== Standard Library

. *Where can I find the most complete documentation on the C++ Standard Library?*
+
Here, the https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library]. The Search feature is useful for locating individual components.

. *How can I be sure when I should use a Boost library or a component of the Standard Library?*
+
Most Boost libraries provide useful and advanced functionality unavailable in the Standard Library. A few Boost libraries have indeed been superseded by the Standard Library, but remain in Boost for backwards compatibility. To determine which you should use, given the choice, consider working through the following process.
+
Note:: When a Boost library is included in the Standard Library, not _all_ of the functionality provided is necessarily standardized. For example, boost:system[] has been standardized but still contains additional functionality not available in the standard. Although standardization might include all of the functionality of a Boost library, performance is not always identical and it can be of value to use the Boost version for higher performance (for example, boost:regex[]). In a few cases, the whole of the Boost library is standardized and the Boost version does not improve on performance (for example, boost:thread[]). 
+
.. Check the Boost library documentation, as their relationship to the Standard Library is sometimes documented. Both the Overview and the Release Notes are good sources of information for mentions of standardization.
.. The https://en.cppreference.com/w/cpp/standard_library[C++ Standard Library] is also well documented. Check to see if the functionality you are looking for is now part of the standard. If you have specific features in mind, comparing the Boost and Standard library functions and classes should provide you with a definitive answer on which to use.
.. If you are less certain of the specific features you need, developers often discuss the status and relevance of Boost libraries in comparison to the standard. Browse, or ask a question in, https://stackoverflow.com/search?q=Boost&s=f447efbc-2ea3-4846-a5d3-0f8676b3f65c[Stack Overflow], https://www.reddit.com/search/?q=Boost+libraries&type=link&cId=28644139-c8b3-48a5-87b6-0c9822188ed4&iId=7f450c5d-6180-4538-a39f-7df7876df4e9&onetap_auto=true&one_tap=true[Reddit], or the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers Mailing List].
.. If you want to dig into the source code, check the activity in the https://github.com/boostorg/boost/tree/master/libs[Boost library's GitHub repository]. Libraries that have been largely superseded have less recent activity compared to those still actively developed and extended. Also check Release Notes for mentions of deprecations or recommendations.
.. Current examples of libraries where you should now use the Standard Library include boost:smart_ptr[] (use `std::shared_ptr`, `std::unique_ptr` etc.), boost:thread[] (use `std::thread`), boost:chrono[] (use `std::chrono`), and boost:random[] (use `std::rand`). Referring to the documentation for these might help show the language used when discussing the relationship with the Standard Library.

. *Are there any Boost libraries currently being considered for inclusion in the Standard Library?*
+
Yes, currently the functionality of two Boost libraries are being considered:
+
.. boost:lambda2[] : for details refer to https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3171r0.html[Adding functionality to placeholder types]
.. boost:fiber[] : for details refer to https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r17.pdf[fiber_context - fibers without scheduler]

. *What is the current status of the Standard Library and when is the next release?*
+
*C++ 2026* is slated as the next full release, for details refer to https://isocpp.org/std/status[Current Status].



== Templates

. *What are pass:[C++] templates?*
+
pass:[C++] templates are a powerful feature of the language that allows for generic programming. They enable the creation of functions or classes that can operate on different data types without having to duplicate code.

. *What are function templates in pass:[C++]?*
+
Function templates are functions that can be used with any data type. You define them using the keyword template followed by the template parameters. Function templates allow you to create a single function that can operate on different data types.

. *What is template specialization in pass:[C++]?*
+
Template specialization is a feature of pass:[C++] templates that allows you to define a different implementation of a template for a specific type or set of types. It can be used with both class and function templates.

. *What are the benefits and drawbacks of using templates in pass:[C++]?*
+
The benefits of using templates include code reusability, type safety, and the ability to use generic programming paradigms. The drawbacks include potentially increased compile times, difficult-to-understand error messages, and complexities associated with template metaprogramming.

. *How can I use templates to implement a generic sort function in pass:[C++]?*
+
Here's an example of how you might use a function template to implement a generic sort function, working with boost:range[], so any type that is supported by this library can be sorted using the following function:
+
[source,cpp]
----
#include <boost/range/iterator_range.hpp>

// Bubble sort using Boost.Range-compatible interface
template<typename Range>
void bubble_sort_range(Range& r) {
    using std::begin;
    using std::end;

    using Iterator = typename boost::range_iterator<Range>::type;
    using Category = typename std::iterator_traits<Iterator>::iterator_category;

    // Enforce random access iterators at compile time
    BOOST_STATIC_ASSERT((std::is_base_of<std::random_access_iterator_tag, Category>::value));

    Iterator first = boost::begin(r);
    Iterator last = boost::end(r);

    if (first == last) return;

    bool swapped = true;
    while (swapped) {
        swapped = false;
        for (Iterator it = first; it + 1 != last; ++it) {
            if (*(it + 1) < *it) {
                std::iter_swap(it, it + 1);
                swapped = true;
            }
        }
        --last;
    }
}

// Usage example:

#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums = { 9, 3, 7, 1, 4, 6, 12, 21, 14, 13, 11, 9, -1, -4 };
    bubble_sort_range(nums);

    for (int n : nums)
        std::cout << n << " ";
    std::cout << "\n";

    std::vector<std::string> names = { "charlie", "alice", "bob", "pete", "vanessa", "dave", "alexi"};
    bubble_sort_range(names);

    for (const auto& name : names)
        std::cout << name << " ";
    std::cout << "\n";
}

----
+
Running the example you should get the output:
+
[source,text]
----
-4 -1 1 3 4 6 7 9 9 11 12 13 14 21
alexi alice bob charlie dave pete vanessa

----

Note:: This use of templates is given as an example only, the `std::sort`, `std::stable_sort`, and `std::spreadsort` are super efficient and should be used whenever possible. However, if you have a special process you would like to apply to different types of ranges, this templated approach may work well for you. For specialized sorts, refer to boost:sort[].

== Types

. *The Boost Libraries have been criticized for using Boost-specific types, do all the libraries use Boost types or do some use standard integers, floats, and strings to name a few of the most-used types?*
+
This question comes up often when people start using Boost seriously. The short answer is "no", not all Boost libraries use Boost-specific types. In fact, many Boost libraries rely primarily on standard types such as `int`, `double`, `std::string`, and `std::vector`. Boost types generally appear only where they add functionality the standard library didn't have at the time — or still doesn't.
+
Most libraries use standard types, such as: boost:math[], boost:algorithm[], boost:random[], boost:accumulators[], boost:multiprecision[], boost:range[], boost:geometry[], https://www.boost.org/doc/libs/master/doc/html/boost_pfr.html[Boost.PFR], boost:describe[].
+
A few libraries use minimal specific types, such as boost:system[], boost:program_options[].
+
The following libraries were introducted _before_ Standard pass:[C++] introduced equivalents: boost:optional[], boost:variant[], boost:function[], boost:any[], boost:filesystem[], boost:smart_ptr[].
+
In some libraries Boost-specfic types are needed for some issues like portability, allocator support, or async control. Such libraries inlude the popular boost:asio[], and others including boost:coroutine2[], boost:context[], boost:lockfree[].
+
For the libraries that require meta-types at compile time, these do require mostly Boost-specific types: boost:mp11[], boost:hana[], boost:type-index[], boost:static-assert[].

. *Can you give me some examples of types added to Boost libraries?*
+
In boost:asio[] the type `boost::asio::context` was added to support a low-level async framework, though does use standard-compatible I/O buffers. In boost:system[], `boost::system::error_code` was added to support location metadata not available in the standard. In boost:optional[] there is the type `boost::optional<T>`, which is now available in the standard library as `std::optional` - but was not available at the time boost:optional[] was released.

. *If I am updating an older version of a codebase, but am not updating the C++ Standard used for that codebase, does it make sense to use Boost libraries?*
+
Boost libraries will provide you with some version independance. For example `std::shared_ptr` and `std::optional` are not available before the pass:[C++] 11 Standard, using boost:shared_ptr[] and boost:optional[] should provide a robust approach to an update of older code.

. *What are the issues with `std::string` that are addressed by Boost libraries such as Static-String, String-Algo, or String-View?*
+
The `std::string` is great for general-purpose English or programming string handling, but has limitations in several key areas: performance (it requires frequent heap allocations and copies), immutability/safety (it can be unintentionally modified or shared), internationization (foreign languages), and feature gaps (it lacks certain high-level string algorithms or fixed-capacity behavior). 
+
For embedded systems, real-time applications, and performance-critical loops consider using boost:static-string[] as it provides a compile-time fixed-capacity string (`boost::static_string<N>`) that eliminates heap allocations.
+
For multi-language software and UTF-8 processing, consider using boost:locale[] for locale-aware comparisons, formatting, and conversions.
+
When working with configuration files, command-line tools, log or protocol parsing - or more advanced tasks such as data validation and pattern recognition - consider the https://www.boost.org/doc/libs/1_83_0/doc/html/string_algo.html[Boost.StringAlgo], boost:regex[], boost:xpressive[], or boost:lexical-cast[] libraries. These libraries offer hundreds of algorithms, views, conversions that will avoid the tedious task of reimplementing string utilities.
+
The boost:utility/doc/html/utility/utilities[Boost.StringView] library has now been superceded by `std::string_view`, available from pass:[C++] 17.

. *Can you show me example code where standard integers and Boost.Multiprecision code work well together?*
+
The following code shows automatic promotion (`big_int += small_int`), arbitrary precision (`cpp_int` grows as large as is needed), high-precision floating point (`area = high_precision_pi * radius * radius`), and interoperability (`approx_area` conversion):
+
[source,cpp]
----
#include <iostream>
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>

namespace mp = boost::multiprecision;

int main() {

    // --- 1. Standard integer and multiprecision integer ---
    std::int64_t small_int = 42;
    mp::cpp_int big_int = 1;

    // Multiply big_int by a large factor
    for (int i = 0; i < 50; ++i)
        big_int *= 10; // No overflow — arbitrary precision!

    // Add standard integer directly — implicit promotion works
    big_int += small_int;

    std::cout << "Big integer (with 42 added): " << big_int << "\n\n";

    // --- 2. Using multiprecision floats with standard numeric types ---
    mp::cpp_dec_float_50 high_precision_pi = 3.14159265358979323846264338327950288419716939937510;
    double radius = 2.5;

    // You can mix standard and multiprecision floats seamlessly
    mp::cpp_dec_float_50 area = high_precision_pi * radius * radius;

    std::cout << std::setprecision(40);
    std::cout << "Area of circle (high precision): " << area << "\n\n";

    // --- 3. Conversion back to standard types ---
    // Note: Narrowing conversions can lose precision
    double approx_area = static_cast<double>(area);
    std::cout << "Area (as double): " << std::setprecision(16) << approx_area << "\n";

    // --- 4. Interoperation example: sum of large values ---
    mp::cpp_int total = 0;
    for (std::int64_t i = 1; i <= 1'000'000; ++i)
        total += i; // summing using high-precision integer

    std::cout << "\nSum of first 1,000,000 integers: " << total << "\n";
}

----
+
Running this code should give you:
+
[source,text]
----
Big integer (with 42 added): 100000000000000000000000000000000000000000000000042

Area of circle (high precision): 19.63495408493620697498727167840115725994

Area (as double): 19.63495408493621

Sum of first 1,000,000 integers: 500000500000
----
+
boost:multiprecision[] is designed to seamlessly extend the built-in numeric types, so you can mix `std::int`, `std::uint64_t`, `double`, and multiprecision types freely — the library's operator overloads handle promotion automatically. Typically, in scientific computing (very large floating point numbers) `cpp_dec_float_50` is combined with `double`, and for working with very large integers (say boundary values), combine `cpp_int` with `std::int64_t` or `std::size_t`.

. *I am having trouble with a multi-platfrom project that requires strings in UTF-8 format, but with Windows APIs requiring UTF-16?*
+
You should conside using boost:nowide[], a library that makes Windows Unicode handling sane! This library provides UTF-8 versions of `fopen`, `std::cout`, as well as file I/O and environmental variables. It also provides the crucial automatic conversion to UTF-16 when calling Windows APIs. You might also find boost:locale[] useful if internationalization is required, boost:static-string[], and the `small_vector` type of boost:container[] for efficient short-string handling.

. *Storage space is of the essence in the real-time app I am building, are there Boost libraries that can provide _small_ integers, specifying 8 or 16 bits and no more storage than that is allocated?*
+
For byte level efficiency look at boost:endian[], this library gives you precise control over both integer size and alignment. It also provides cross-platfrom compatibility, if that is important. For example, `boost::endian::little_int8_t  smallCount;` will always be 8 bit. boost:multiprecision[] does provide for declaring small integers as low as 8 bits, but is not so memory efficient. If your goal is to save overall memory, not just per-number bytes, check out boost:container[], as it supports small-vector optimization and no heap allocations.

== See Also

* xref:contributor-guide:ROOT:contributors-faq.adoc[Contributor Guide FAQ]
* xref:explore-the-content.adoc[]
* xref:glossary.adoc[]
* xref:resources.adoc[]

