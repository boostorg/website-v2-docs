////
Copyright (c) 2024 The C++ Alliance, Inc. (https://cppalliance.org)

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

Official repository: https://github.com/boostorg/website-v2-docs
////
= Contributors Frequently Asked Questions
:navtitle: Contributors FAQ

This section contains answers to the common questions that new contributors to Boost often have.

== Topics

[square]
* <<Adding New Libraries>>
* <<Boost Software License>>
* <<Development Environments>>
* <<Existing Boost Libraries>>
* <<Modular Boost>>
* <<Post-Release Engagement>>
* <<Safe C++>>
* <<Security>>
* <<Testing>>

== Adding New Libraries

. *When considering developing a library for Boost, what is the right balance between ambitious functionality and limited functionality?*
+
The keys to a successful development of a new library are to identify core functionality and start simple. Prioritize functionality that provides significant value to developers and aligns with Boost's goals of promoting high-quality, reusable libraries. Avoid adding unnecessary features that may increase complexity without adding much value. It's often beneficial to start with a simpler implementation that addresses a specific problem or use case effectively. A library with a narrow focus and a clear, intuitive API is more likely to be accepted by the Boost community than one that attempts to solve too many problems at once or introduces unnecessary complexity.
+
In addition to this, consider future extensibility, performance, portability, current trends, and always remember you can seek community advice and feedback through the Boost mailing lists.


[[boostsoftwarelicense]]
== Boost Software License

. *Where can I read the current version of the Boost Software License?*
+
Here: xref:user-guide:ROOT:bsl.adoc[The Boost Software License].

. *How should Boost programmers apply the license to source and header files?*
+
Add a multi-line comment based on the following template, substituting appropriate text for the name and date on the top line:
+
[source,cpp]
----
//          Copyright Joe Coder 2004 - 2006.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)
----
Notes::
+
a. Leave an empty line before and after the above comment block.
+
b. It is fine if the copyright and license messages are not on different lines; in no case should there be other intervening text.
+
c. Do not include "All rights reserved" anywhere.
+
d. Other ways of licensing source files have been considered, but some of them turned out to unintentionally nullify legal elements of the license. Having fixed language for referring to the license helps corporate legal departments evaluate the Boost distribution.
+
e. Creativity in license reference language is strongly discouraged, but judicious changes in the use of whitespace are fine.

. *How should the license be applied to documentation files rather than source files?*
+
Similarly to the way it is applied to source files: the user should see the very same text indicated in the template above, with the only difference that your local copy of LICENSE_1_0.txt should also be linked to.

. *How should Boost programmers maintain the copyright messages?*
+
Copyright is only claimed for changes meeting a certain threshold of originality. Therefore, the copyright message only covers expressions of creativity. It is up to authors of changes to add themselves to the copyright message if they so decide. Typically, a new claimant is added when someone takes over maintenance of a library or a new version of an existing library is developed. In principle, do not remove previous copyright claims - just add new claims and/or claimants.

. *How is the Boost Software License (BSL) different from the GNU General Public License (GPL)?*
+
The https://opensource.org/license/gpl-3-0[GNU General Public License] is longer, and may be harder to understand. The Boost license permits the creation of derivative works for any use with no legal requirement to release your source code. Other differences include BSL not requiring reproduction of copyright messages for object code redistribution, and the fact that BSL is not "viral": if you distribute your own code along with some Boost code, the BSL applies _only_ to the Boost code (and modified versions thereof); you are free to license your own code under any terms you like.

. *Why the phrase "machine-executable object code generated by a source language processor"?*
+
To distinguish cases where we do not require reproduction of the copyrights and license (such as object libraries, shared libraries, and final program executables), from cases where reproduction is still required (such as distribution of self-extracting archives of source code or precompiled header files). More detailed wording was rejected as not being legally necessary, and reducing readability.

. *Why is the "disclaimer" paragraph of the license entirely in uppercase?*
+
Capitalization of these particular provisions is a US legal mandate for consumer protection.

. *Does the copyright and license cover interfaces too?*
+
The conceptual interface to a library is _not_ covered. The particular representation expressed in the header is covered, as is the documentation, examples, test programs, and all the other material that goes with the library. A different implementation is free to use the same logical interface, however. Interface issues have been fought out in court several times; refer to a lawyer if this is likely to be an issue.

. *Why doesn't the license prohibit the copyright holder from patenting the covered software?*
+
No one who distributes their code under the terms of this license could turn around and sue a user for patent infringement. Boost's lawyers were well aware of patent provisions in licenses like the GPL and CPL, and would have included such provisions in the Boost license if they were believed to be legally useful.

. *Why doesn't the copyright message say "All rights reserved"?*
+
This provision does not belong in the copyright notice for anything (software, electronic documentation, etc.) that is being licensed. It belongs in books that are sold where, in fact, all rights (for example, to reproduce the book, etc.) are being reserved by the publisher or author.

. *Do I have to copyright/license trivial files?*
+
Yes, even a test file that just contains an empty `main()` should have a copyright notice. Files without copyright notices make corporate lawyers nervous, and that's a barrier to adoption. The more Boost is uniformly copyrighted and licensed, the better.

. *Can I use the Boost Software License for my own projects outside of Boost?*
+
Yes, there are no restrictions on the use of the license itself.

. *Is the Boost license Open Source?*
+
Yes. The https://opensource.org/[Open Source Initiative] certified the https://opensource.org/license/bsl-1-0[Boost Software License 1.0 in early 2008].


== Development Environments

. *Many developers opt for lightweight integrated developer environments (IDEs), rather than the full-fledged IDE. What lightweight IDEs are popular for pass:[C++] development?*
+
There are several popular options for both Windows and Linux. https://www.jetbrains.com/clion/[CLion], developed by JetBrains, is a cross-platform IDE that offers advanced code analysis, refactoring tools, and integration with the CMake build system, which is commonly used in pass:[C++] projects.
+
https://www.gnu.org/software/emacs/[GNU Emacs] and https://www.vim.org/[Vim] are highly configurable and popular among developers who prefer a more minimalistic environment. They offer powerful features for editing code, and many plugins are available to enhance development workflows.
+
https://www.qt.io/product/development-tools[Qt Creator] provides features like code completion, syntax highlighting, and debugging support for pass:[C++] and Qt (projects that use the Qt framework).
+
https://www.sublimetext.com/index2[Sublime Text] is a lightweight yet powerful text editor known for its speed and simplicity. It offers features like syntax highlighting, multiple selections, and a wide range of plugins for enhancing functionality, including support for pass:[C++] development.
+
https://atom-editor.cc/[Atom] is an open-source text editor developed by GitHub. It's highly customizable and extensible through packages, and provides features like syntax highlighting, auto-completion, and project navigation.
+
There are many other tools, Microsoft's https://visualstudio.microsoft.com/[Visual Studio] provides a full IDE and is well respected as a professional development environment, and https://code.visualstudio.com/Download[Visual Studio Code] is a lighter weight but versatile code editor that can be extended and customized with various extensions.


== Existing Boost Libraries

. *What are the biggest pain points that developers are running into, that are not addressed by current Boost libraries?*
+
Some Boost libraries have a steep learning curve, especially for newcomers to pass:[C++]. Simplifying the API design, providing  extensive documentation, and offering beginner-friendly tutorials helps lower the barrier to entry and make your library more accessible to a wider audience. Other pain points include support for modern language features, working with concurrency and parallelism, providing a seamless experience across different platforms, and providing optimal performance.

. *For reference, what libraries are good examples of ones that are easy to learn?*
+
One library known for its relatively straightforward API and ease of learning compared to some others is boost:filesystem[]. 
This library provides portable facilities to work with files and directories, offering an intuitive interface for common file system operations such as file creation, deletion, copying, moving, and directory traversal. Its design is user-friendly and follows familiar patterns. boost:filesystem[] documentation is comprehensive and well-structured. Overall, boost:filesystem[] is often recommended as a starting point for those looking to dip their toes into Boost libraries due to its simplicity, practicality, and broad applicability across various projects.
+
Other libraries that are known for their shallow learning curve include boost:optional[] which is particularly useful for handling functions that may return an optional value or dealing with nullable data types in a safe and clear manner. boost:any[] allows developers to store objects of different types in a single container and retrieve them without typecasting. boost:type-index[]  provides facilities for obtaining type information at runtime, making it easy to work with types dynamically.

. *What libraries have the steepest learning curve?*
+
While all Boost libraries have their complexities, some are known to have steeper learning curves due to their advanced nature or the intricacies of the domain they address. boost:spirit[] is a parsing and generation library that uses a domain-specific embedded language (DSEL) implemented as pass:[C++] template metaprograms. It allows developers to define parsers and generators directly within code using EBNF-like syntax. However, the template-based approach and the metaprogramming techniques used can make it challenging for newcomers to grasp, especially those unfamiliar with advanced template programming or parsing theory.
+
boost:mp11[] (Meta-Programming Library) is a powerful library for metaprogramming, providing tools for compile-time computation, type manipulation, and template metaprogramming. It allows developers to perform complex compile-time computations and transformations using a functional programming style. However, the functional programming paradigm and the intricacies of template metaprogramming can be daunting for beginners and require a solid understanding of pass:[C++] templates and meta-programming concepts.

. *What libraries were the most ambitious in what they attempted to achieve?*
+
The many notable examples include:
+
* boost:graph[] provides a generic and efficient framework for working with graphs, making it suitable for a variety of applications in areas such as network analysis, optimization, and data visualization.
* boost:compute[] provides abstractions for memory management, kernel execution, and data parallelism, enabling developers to harness the computational power of modern hardware for tasks such as numerical simulations, image processing, and machine learning.
* boost:spirit[] is ambitious in its goal of providing a high-level and composable framework for parsing complex data formats and domain-specific languages entirely within pass:[C++] code, without the need for external tools or preprocessors.
* boost:hana[] aims to simplify and modernize metaprogramming in pass:[C++], making it more accessible and powerful for developing generic libraries and applications.

. *What libraries were the least ambitious technically?*
+
The useful utilities such as boost:any[], boost:variant[], and boost:optional[] offer relatively simple functionality. Another simpler library is boost:bimap[] which provides a container for maintaining one-to-one mappings between keys and values. While bidirectional maps are a useful data structure, the functionality provided is relatively straightforward and focused on this specific use case.


== Modular Boost

. *What is meant by "Modular Boost"?*
+
Technically, Modular Boost consists of the Boost super-project and separate projects for each individual library in Boost. In terms of Git, the Boost super-project treats the individual libraries as submodules. Currently (early 2024) when the Boost libraries are downloaded and installed, the build organization does _not_ match the modular arrangement of the Git super-project. This is largely a legacy issue, and there are advantages to the build layout matching the super-project layout. This concept, and the effort behind it, is now known as "Modular Boost".
+
In the past, the term has been used more broadly to refer simply to libraries in different repositories. This definition has now been tightened to mean a flat layout where each library is in its own sub-module, and there are no sub-libraries as there have been in the past (for example, the `numeric` libraries).
+
Refer to xref:superproject/overview.adoc[] for a full description of the super-project.

. *What exactly is a "modular arrangement"?*
+
It's when the libraries can be used, and hence built, without creating the monolithic headers, without needing the root build files, and without needing the libraries to be arranged in the usual `root/libs/<name>` format.

. *Will the move to Modular Boost change testing?*
+
No, unless you want to. You will still be able to test with the current non-modular way. But you could also test the modular way.

. *How will modular Boost work if there is no `root/libs/<name>` structure? Or is the structure still required?*
+
The structure is still required for things like testing and documentation building.

. *What happens to the numeric libraries that are currently sub-libraries, when sub-libraries are no longer supported?*
+
The numeric libraries have been divided into four packages: libboost-numeric-conversion/, libboost-numeric-interval/, libboost-numeric-odeint/, libboost-numeric-ublas/.


== Post-Release Engagement

. *Through what channels do Boost library authors typically receive the most feedback?*
+
Primarily the https://lists.boost.org/mailman/listinfo.cgi/boost-users[Boost Users Mailing List] and the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers Mailing List]. In addition, checkout GitHub Issues and Pull Requests. Also, the Boost forums on https://slack.com/[Slack] can be active.
+
Example of communication flow:
+
.. A new library release is announced on the Boost mailing lists.
.. Users start discussing the new release on the mailing lists, reporting initial impressions and any issues encountered.
.. Users report bugs and request features on the relevant GitHub repository, leading to active discussions in the issues and pull requests sections.
.. Boost library authors and contributors discuss technical details and implementation strategies on the https://lists.boost.org/mailman/listinfo.cgi/boost[Boost Developers Mailing List].
.. Users seeking immediate help might turn to https://slack.com/[Slack] or sometimes https://discord.com/[Discord] for quick responses, or directly communicate with the authors if email or forum addresses are made public.

. *What kind of communication from the pass:[C++] developer community have library authors received after public release of their library into the Boost collection?*
+
Authors often receive a variety of feedback, which should be welcomed to help authors gauge the acceptance and usability of their library. Feedback can be categorized into several types:
+
.. General feedback includes both positive and negative comments about the overall design, usability, and documentation of the library. The most common comments include praise for a well-designed API, criticism of complex or confusing documentation, and suggestions for improving user experience.
.. Developers may ask for help or clarification on how to use certain features of the library, especially clarifications on API usage. Another common request is for example code to demonstrate specific use cases, or help with integrating the library into their own projects.
.. Bug reports or issues developers encounter while using the library. These can range from minor issues, such as documentation typos, to major bugs that affect the functionality of the library. The more serious examples include: inconsistent behavior across different platforms, crashes or memory leaks in certain use cases, or incorrect results from specific functions.
.. Feature requests are not uncommon, such as support for additional platforms or compilers, new algorithms or data structures, or performance improvements and optimizations.
.. Performance feedback related to the performance of the library, including benchmarking results and suggestions for optimizations. Typically this centers around reports of slow performance in certain scenarios, comparisons with similar libraries, or suggestions for algorithmic improvements.
.. Portability issues are also to be expected, related to building or running the library on different platforms, operating systems, or compilers. Obvious issues include compilation errors on specific platforms, incompatibilities with certain compiler versions, or issues with platform-specific dependencies.
.. There can be integration feedback on how well the library integrates with other libraries, frameworks, or tools in the C++ ecosystem. This can include integrating even with other Boost libraries as well as other third-party libraries.
.. Finally, it is important to remember that members of the community can contribute to a library by submitting patches, improvements, or additional features. These updates tend to focus on code optimizations, and bug fixes. Less often they are enhancements to the library's functionality.

. *Can you give me some examples of user requests for library improvements and describe the response from the authors or maintainers?*
+
* boost:asio[] received numerous bug reports and feature requests related to its asynchronous I/O capabilities. Users asked for better documentation and examples for common use cases, such as implementing network protocols. The author, Christopher M. Kohlhoff, responded by improving documentation and providing more examples and tutorials. The library also received several community-contributed enhancements and bug fixes.
+
* boost:python[] users reported issues related to compatibility with different versions of Python and pass:[C++] compilers. There were also many requests for new features to better support modern pass:[C++] standards and Python 3.x. The maintainers addressed these issues by updating the library to support newer Python versions and pass:[C++] standards. The community also contributed patches to fix compatibility issues and add new features.
+
* boost:spirit[], a library for creating parsers and generators, received feedback about its steep learning curve and complex documentation. Users requested more tutorials and simpler examples. The authors and the community worked on improving the documentation and providing more examples. The library also saw several enhancements to make it more user-friendly and easier to learn.
+
* boost:thread[] ran into issues with changes in the pass:[C++]11 standard library, which introduced its own threading support.
The authors had to adapt boost:thread[] to coexist with and complement the standard library's threading facilities, leading to significant refactoring.
+
* boost:graph[] initially included some incorrect assumptions about graph properties and algorithms, this led to bugs that required reworking the design to support a wider range of graph types and use cases.
+
* boost:math[] initially had issues in mathematical algorithms that produced incorrect results in some cases, and required redesigning the affected components to ensure greater robustness.
+
* boost:interprocess[] had some bugs related to shared memory management that led to memory corruption, requiring a redesign of the allocation and synchronization mechanisms.
+
* boost:filesystem[] early versions had an API that was inconsistent and difficult to extend. The introduction of the v3 API addressed these issues, providing a more robust and user-friendly interface.
+
* boost:multi-index[] had performance issues with certain types of queries and modifications which required rethinking the internal data structures and algorithms to improve efficiency.
+
* boost:geometry[] had performance bottlenecks in spatial indexing and query algorithms. This required redesigning parts of the library to handle large datasets more efficiently.
+
* boost:regex[] had issues with regular expression processing that could be exploited for denial-of-service attacks. This required redesigning parts of the matching engine to improve security and robustness. Refer to <<security>> for more details.
+
* boost:serialization[] also had <<security>> issues - vulnerabilities in handling serialized data could lead to arbitrary code execution or data corruption. This was addressed with changes to the serialization mechanisms.

. *What have been the most unpleasant surprises that Boost library authors have to deal with?*
+
Here are some of the most notable ones:

.. Changes in the pass:[C++] standard or the introduction of new features can sometimes break backward compatibility, leading to user complaints and requiring significant effort to fix.
.. Authors have encountered unexpected behavior or compilation errors on less common platforms, requiring extensive debugging and platform-specific fixes.
.. Boost has its own boost:build[] system (though CMake can also be used), which can be complex and difficult for new users to understand. Authors have received feedback about difficulties in building the library, leading to extensive support and documentation efforts to help users get started.
.. Authors have had to deal with unexpected slowdowns (performance regressions) reported by users, requiring detailed performance analysis and sometimes reworking or reverting changes.
.. Users often have high expectations, and meeting these expectations can be challenging, especially for volunteer-driven projects. Authors sometimes face criticism for perceived shortcomings in these areas.
.. _Dependency hell_ : there can be a complex web of dependencies, and managing these dependencies can be challenging, especially when changes in one library affect others. Authors sometimes find it difficult to keep everything in sync.
.. Like all software, Boost libraries can have security vulnerabilities that need to be addressed promptly. Carefully read the <<security>> section.
.. Managing contributions from the community, ensuring code quality, and handling disagreements can be challenging.
.. Writing and maintaining comprehensive documentation is crucial but often neglected due to the focus on coding.

. *What mitigation strategies have Boost library authors employed to mitigate these unpleasant surprises?*
+
Primarily implementing a comprehensive xref:testing/boost-test-matrix.adoc[Test Matrix] to catch issues early. xref:testing/continuous-integration.adoc[Continuous Integration (CI)] systems ensure consistent builds and tests across multiple platforms and configurations. Also actively engaging with the community through forums, mailing lists, and GitHub to gather feedback and address issues promptly. Last but not least, investing time in writing clear, detailed xref:docs/layout.adoc[Documentation] and tutorials to help users get started and understand complex features.
+
After the initial release, consider releasing regular updates to address bugs, improve performance, and add features as necessary, based on user feedback. Refer to xref:version-control.adoc[].
+
Note:: Whereas promptly addressing issues is important, haste is not always the right approach. When critical bugs are identified, detailed bug reports are needed, and the library authors and contributors analyze the bugs, discuss possible solutions, and plan the necessary changes. Significant redesign or refactoring of the affected parts of the library may be needed to address the issues. This will involve extensive testing and should not be rushed.

. *About how long following release of a library does it take before communication dies down, say to just an occasional email or forum question?*
+
The duration and intensity of communication following the release of a Boost library obviously varies widely depending on several factors, the complexity and popularity of the library, the initial quality of the release, and the responsiveness of the authors to early feedback. However, a general pattern has been observed:
+
* During the _initial surge_ (0-3 months) the communication intensity is high. Authors are typically engaged and active during this period, addressing issues promptly, releasing patches or updates, and improving documentation based on feedback.
* A _stabilization period_ (3-12 months) follows, with moderate feedback. Authors continue to be engaged but may start shifting focus to other projects or new features for the library, so response times can slow.
* The _maturity phase_ (12+ months) involves sporadic communication, often related to edge cases or specific environments. Authors may check in periodically but are generally less active unless major issues arise or a significant update is planned.
+
More complex libraries (for example, boost:spirit[] or boost:asio[]) tend to have longer periods of active communication due to their advanced features and higher potential for integration challenges. Libraries that quickly gain a large user base will have prolonged and more intense periods of communication. Popular libraries like boost:python[] tend to have more sustained engagement. *Libraries with thorough initial documentation and fewer bugs tend to stabilize faster.* Poor documentation or frequent bugs can extend the period of high communication.

. *Say developers greatly appreciate a new library, what kind of praise have they given, or have they remained fairly silent?*
+
Silence is common but praise does come in various ways, both publicly and privately. The feedback can be quite enthusiastic and detailed, highlighting the library's impact on their work and its overall quality. Developers often post messages of appreciation on the Boost mailing lists or Slack forums. These posts can range from simple thank-yous to detailed accounts of how the library has helped solve specific problems: _"boost:python[] has significantly reduced the complexity of integrating pass:[C++] with Python in our project. The documentation is clear, and the API is intuitive. Kudos to the developers!"_
+
Praise is also shared on social media platforms like X, LinkedIn, and personal or company blogs. Developers might write blog posts detailing their experiences and the benefits they've gained from using the library: _"Just integrated boost:asio[] into our server application. The performance improvements are phenomenal! Big thanks to the Boost community!"_
+
Developers might mention and praise Boost libraries in their talks at conferences or meetups. They often showcase how they used the library to solve challenging problems: for example, a presentation at https://github.com/CppCon[CppCon] highlighted the use of boost:hana[] for metaprogramming and how it simplified complex template code.
+
Private emails to the library authors expressing their gratitude and sharing success stories are also not uncommon.
For example _"I wanted to thank you for your work on boost:graph[]. It has been instrumental in our network analysis tool. Your dedication and support are greatly appreciated."_
+
_"The documentation for boost:spirit[] is outstanding. The examples made it easy to get started and understand the complex concepts."_
+
_"boost:multi-index[] has drastically improved our query performance. The library's efficiency and flexibility are top-notch."_
+
_"Integrating boost:beast[] for our HTTP server was seamless. The design and ease of use are commendable."_
+
_"boost:filesystem[] has been rock-solid in our cross-platform application. It handles all edge cases gracefully."_
+
Positive feedback and praise from developers not only encourages the library authors but also helps promote the library within the wider community. This can lead to increased adoption, further contributions, and continuous improvement of the library by the community. It can of course lead to additional communication.
+
Financial contributions or sponsorships as a token of appreciation are rare!

[[safecpp]]
== Safe C++

. *As a contributor of a library to Boost, what do I need to know about Safe pass:[C++]?*
+
Currently, https://safecpp.org/P3390R0.html[Safe pass:[C++]] is a proposal, under discussion, to develop a memory-safe set of extensions to pass:[C++]. The push is because the current lack of memory safety makes it too easy for malicious software to exploit language vulnerabilities and perform a variety of attacks. Safe pass:[C++] would provide robust memory-safe, type-safe, and thread-safe operations.
+
Clearly there could be significant interest in safe versions of Boost libraries, though the level of work involved extends well beyond rewriting a library using the safe extensions, as _all_ dependencies would also have to be safe versions too.
+
Both the stakes and the workloads are high! If the proposal leads to a solid set of extensions, then as a library developer you will have a decision to make - whether to refactor your library using these extensions, or not. Many factors might influence this decision.

. *Is Safe C++ part of Boost?*
+
No, it is an independent initiative. The pass:[C++] Alliance has partnered with Sean Baxter, a key proponent of Safe pass:[C++], to further develop the proposal, and seek feedback from developers, researchers, and other stakeholders to refine the project's scope.

. *Is there an official release schedule for Safe C++?*
+
No, it is still at the proposal and design refinement stage.

. *What kind of feedback has the proposal garnered so far?*
+
Positive feedback centers on appreciation of the initiative to address longstanding safety concerns in pass:[C++]. More challenging feedback has included concerns about the complexity of integrating new safety features into the existing pass:[C++] framework, balancing enhanced safety with the language's core design features of performance and flexibility, and competition from the https://www.rust-lang.org/[RUST] and https://developer.apple.com/swift/[Swift] programming languages.

. *Are there references I can read that will help me understand safe concepts and so understand the online discussions?*
+
Yes, in addition to the https://safecpp.org/P3390R0.html[Safe pass:[C++] proposal] from Sean Baxter, the https://herbsutter.com/2024/03/11/safety-in-context/[pass:[C++] safety, in context] blog post, by Herb Sutter, has been written for a broad audience. Also by Herb Sutter, there is a paper entitled https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3081r0.pdf[Core safety Profiles: Specification, adoptability, and impact].
+
If you refer to the *References* section of any of these papers, you will find a range of books, papers, presentations and the like that delve to various depths into safety issues. For example, the https://open-std.org/JTC1/SC22/WG21/docs/papers/2023/p2816r0.pdf[Safety Profiles:Type-and-resource Safe programming in ISO Standard pass:[C++]], by Bjarne Stroustrup and Gabriel Dos Reis, outlines a talk on the broad spectrum of safety issues in a chattier style than the more formal programming papers - and might be a good place to start!

. *Can you recommend some Boost libraries that demonstrate current best safe-coding practices?*
+
By examining the source code and documentation for any of these libraries, you should be able to educate yourself on a robust approach to safe programming, using current development tools.
+
For _memory safety_, boost:smart_ptr[] provides smart pointer types like `boost::shared_ptr`, `boost::weak_ptr`, and `boost::scoped_ptr` to manage dynamic memory safely and avoid common pitfalls like memory leaks and dangling pointers. boost:pool[] offers memory pooling utilities that efficient managing of memory allocations while minimizing fragmentation. It can help show how to avoid unsafe manual memory management.
+
For _type-safety_, boost:static-assert[] facilitates compile-time checks with `BOOST_STATIC_ASSERT`, ensuring that certain conditions are met during compilation, thus improving type safety. Also, boost:type-traits[] supplies a set of tools for type introspection, enabling safer template programming by providing ways to query and manipulate types.
+
For _resource-safety_ boost:filesystem[] is designed to work with file paths and directories safely, minimizing errors in handling filesystem resources and ensuring proper cleanup. boost:scope_exit[] provides a mechanism for ensuring cleanup of resources (e.g., releasing locks or closing file handles) when a scope is exited, both normally or due to an exception. And boost:interprocess[] facilitates safe and efficient interprocess communication (IPC), managing shared memory and other resources in a resource-safe way.
+
For _thread-safety_ boost:thread[] offers portable thread management and synchronization primitives (such as `boost::mutex`, `boost::lock_guard`) to help developers write thread-safe code. boost:asio[] enables asynchronous I/O operations with an emphasis on thread safety, making it easier to build safe and scalable networked applications. At a lower level, boost:atomic[] provides atomic operations for thread-safe programming, avoiding data races in concurrent applications.
+
For a more general approach to safety, boost:optional[] introduces a way to handle optional values safely, avoiding issues like null pointer dereferencing.
boost:variant2[] provides a type-safe `union` type, ensuring that only one active type is stored at any time, preventing type misuse errors. boost:coroutine2[] implements stackful coroutines with resource management in mind, preventing unsafe usage patterns.

. *Using current development tools what are the design principles of safe programming?*
+
Current best practices start with the use of static and compile-time checks to enforce constraints early. For resource-safety the idiom is  _Resource Acquisition Is Initialization_ (RAII). This idiom ties the lifetime of a resource to a programming object, so that when the object is created the resource is initialized, and when the object is destroyed the resource is released. However, the central theme of current safety is _Encapsulation_ - the encapsulation of known unsafe operations in well-tested, robust, reusable abstractions, for example:

*** Instead of exposing raw pointers, use smart pointers or custom encapsulation to ensure safe memory management:
+
[source,cpp]
----
//
// Unsafe code
// 

int* allocateArray(size_t size) {
    return new int[size];
}

void useArray() {
    int* arr = allocateArray(10);

    // No bounds checking.
    arr[10] = 42;

    // Forgetting to delete could cause memory leaks.
    delete[] arr;
}

//
// Safe encapsulation
// 

#include <vector>
#include <memory>

class SafeArray {
private:
    std::unique_ptr<int[]> data;
    size_t size;

public:
    SafeArray(size_t size) : data(std::make_unique<int[]>(size)), size(size) {}

    int& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }

    size_t getSize() const { return size; }
};

void useSafeArray() {
    SafeArray arr(10);
    
    // Safe access
    arr[0] = 42; 
    try {

        // Throws an exception
        arr[10] = 13; 
    } catch (const std::out_of_range& e) {
        std::cerr << e.what() << std::endl;
    }
}

----
+
*** Handle file operations safely by ensuring that the file is properly closed after use.
+
[source,cpp]
----
//
// Unsafe code
// 

void writeFile(const std::string& filename) {
    FILE* file = fopen(filename.c_str(), "w");
    if (file) {
        fputs("Hello, World!", file);

        // Forgetting fclose could cause resource leaks.
    }
}

//
// Safe encapsulation
// 

#include <fstream>
#include <string>

class FileHandler {
private:
    std::ofstream file;

public:
    explicit FileHandler(const std::string& filename) {
        file.open(filename, std::ios::out);
        if (!file) {
            throw std::ios_base::failure("Failed to open file");
        }
    }

    ~FileHandler() {
        if (file.is_open()) {
            file.close();
        }
    }

    void write(const std::string& content) {
        if (!file) {
            throw std::ios_base::failure("File not open");
        }
        file << content;
    }
};

void safeWriteFile(const std::string& filename) {
    try {
        FileHandler fh(filename);
        fh.write("Hello, World!");
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

----
+
*** Prevent race conditions by wrapping shared resources in a thread-safe interface.
+
[source,cpp]
----
//
// Unsafe code
// 

#include <iostream>
#include <thread>
#include <vector>

int counter = 0;

void incrementCounter() {
    for (int i = 0; i < 1000; ++i) {

        // Race condition
        ++counter; 
    }
}

void unsafeThreads() {
    std::thread t1(incrementCounter);
    std::thread t2(incrementCounter);
    t1.join();
    t2.join();

    // Undefined behavior
    std::cout << "Counter: " << counter << std::endl;
}

//
// Safe encapsulation
// 

#include <iostream>
#include <thread>
#include <vector>
#include <mutex>

class ThreadSafeCounter {
private:
    int counter = 0;
    std::mutex mtx;

public:
    void increment() {
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
    }

    int get() const {
        return counter;
    }
};

void safeThreads() {
    ThreadSafeCounter counter;

    auto worker = [&counter]() {
        for (int i = 0; i < 1000; ++i) {
            counter.increment();
        }
    };

    std::thread t1(worker);
    std::thread t2(worker);
    t1.join();
    t2.join();
    
    // Guaranteed correct result
    std::cout << "Counter: " << counter.get() << std::endl; 
}

----
+
*** Instead of using raw sockets, encapsulate them in a class that ensures proper resource cleanup.
+
[source,cpp]
----
//
// Unsafe code
// 

#include <sys/socket.h>
#include <unistd.h>

int createSocket() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("Socket creation failed");
        return -1;
    }

    // Forgetting close(sock) could cause resource leaks.
    return sock;
}

//
// Safe encapsulation
// 

#include <sys/socket.h>
#include <unistd.h>
#include <stdexcept>

class SafeSocket {
private:
    int sock;

public:
    SafeSocket() {
        sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock == -1) {
            throw std::runtime_error("Socket creation failed");
        }
    }

    ~SafeSocket() {
        if (sock != -1) {
            close(sock);
        }
    }

    int getSocket() const {
        return sock;
    }
};

----
+
By wrapping low-level operations in safe abstractions, you make the code easier to use and much harder to misuse!

[[security]]
== Security

. *What are the known security vulnerabilities of the language pass:[C++] that I should be aware of when developing my Boost library?*
+
There are several known security vulnerabilities and pitfalls associated with the pass:[C++] language that developers should be aware of when developing libraries. Leveraging security tools, static analysis, and code reviews can help identify and address security issues early in the development lifecycle. In particular, be aware of:
+
* _Buffer overflows_ occur when data is written beyond the boundaries of a fixed-size buffer, leading to memory corruption and potential exploitation. This vulnerability can be exploited by attackers to execute arbitrary code, crash the application, or manipulate program behavior.
+
* _Null Pointer Dereferences_ (accessing memory at address 0) can lead to undefined behavior, crashes, or security vulnerabilities. Null pointer dereferences are a common source of application instability and can be exploited by attackers to cause denial-of-service conditions or execute arbitrary code.
+
* _Memory leaks_ occur when memory allocated dynamically is not properly deallocated, leading to the exhaustion of available memory over time. While memory leaks may not directly result in security vulnerabilities, they can indirectly impact system stability and performance, potentially facilitating denial-of-service attacks or other security incidents.
+
* _Deprecated functions_ and APIs may be insecure or outdated, exposing applications to known vulnerabilities or security risks. Developers should avoid using deprecated functions and select modern, secure alternatives provided by the latest Boost or Standard libraries.
+
* _Integer overflows and underflows_ occur when arithmetic operations result in values that exceed the range of representable integer types. These vulnerabilities can lead to unexpected behavior, data corruption, or security vulnerabilities, especially in security-critical code paths such as input validation or memory allocation.
+
* _Insecure input handling_, such as failure to validate input data or sanitize user input, can lead to injection attacks or buffer overflows. Developers should validate and sanitize input data to ensure that it meets expected criteria and is safe to process further.
+
* _Unsafe type conversions_, such as casting pointers between incompatible types or using implicit type conversions without validation, can lead to memory corruption or data integrity issues. Developers should use explicit type conversions and perform appropriate validation to prevent unintended behavior.
+
* _Concurrency and synchronization issues_, such as data races, deadlocks, and race conditions, can lead to unpredictable behavior and security vulnerabilities in multithreaded applications. Developers should use thread-safe synchronization primitives and adopt best practices for concurrent programming.

. *Are there certain kinds of tests or certain testing styles that work well when trying to identify and remove security liabilities in pass:[C++] code?*
+
There are several types of tests and testing techniques that can be particularly effective for identifying and mitigating security vulnerabilities in pass:[C++] code, consider:
+
* _Unit testing_ involves testing individual components or units of code in isolation to ensure they behave as expected. Writing comprehensive unit tests for critical functions, classes, and modules helps verify their correctness and robustness, including edge cases, boundary conditions, and error handling paths. Refer to xref:testing/writing-tests.adoc[].
+
* _Fuzz testing_, also known as fuzzing, involves providing invalid, unexpected, or random input data to the program to identify potential vulnerabilities such as buffer overflows, null pointer dereferences, and other memory-related issues. Fuzz testing tools generate large volumes of test cases automatically and monitor the program's behavior for crashes, hangs, or unexpected outputs. Refer to xref:testing/fuzzing.adoc[].
+
* _Static analysis_ tools analyze source code without executing it and identify potential security vulnerabilities, code smells, and best practice violations. Static analysis tools for pass:[C++] can detect issues such as buffer overflows, null pointer dereferences, integer overflows, uninitialized variables, and unsafe type conversions.
+
* _Dynamic analysis_ involves analyzing the behavior of the program during execution to identify security vulnerabilities, memory leaks, and runtime errors. Dynamic analysis tools for pass:[C++] can detect issues such as memory corruption, resource leaks, concurrency issues, and other runtime anomalies. Dynamic analysis techniques include memory sanitizers, address sanitizers, thread sanitizers, and runtime instrumentation. Refer to xref:testing/sanitizers.adoc[].
+
* _Penetration testing_, also known as _pen testing_ or sometimes _ethical hacking_, involves simulating real-world attacks against the software to identify security vulnerabilities and assess the effectiveness of existing security measures.
+
* Finally, _code reviews_ conducted by peers, security experts, or automated tools, and focus on identifying potential security vulnerabilities, design flaws, and implementation errors. 

. *Are there Boost libraries that would help me guard against null pointer dereferencing?*
+
While there is not a specific library dedicated solely to null pointer dereference prevention, you can leverage several libraries:
 
 * boost:smart_ptr[] provides smart pointer classes such as `shared_ptr`, `unique_ptr`, and `weak_ptr`, which help manage dynamic memory allocation and deallocation automatically. Smart pointers implement https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization[RAII (Resource Acquisition Is Initialization)] semantics, ensuring that memory is properly released when it goes out of scope or is no longer needed. By using smart pointers instead of raw pointers, you can reduce the risk of null pointer dereferencing errors, as smart pointers automatically handle null checks and memory deallocation.
+
* boost:optional[] provides a type-safe wrapper for optional values, allowing you to represent nullable objects without resorting to raw pointers or null references.
+
* boost:assert[] provides macros and utilities for defining runtime assertions and preconditions in your code. You can use assertions to validate assumptions and guard against null pointer dereferences by checking for null pointers before dereferencing them.
+
* boost:contract[] provides a framework for specifying and enforcing function contracts, including preconditions, postconditions, and invariants. You can use contracts to define and enforce conditions that must be satisfied by function parameters, return values, and object states, including null pointer checks.

. *Are there Boost libraries that I could include in my library project that help with secure input validation?*
+
There are several libraries that provide functionalities for input validation, sanitization, and handling, helping to mitigate security vulnerabilities related to invalid or malicious input data:
+
* https://www.boost.org/doc/libs/1_83_0/doc/html/string_algo.html[Boost.String_Algo] provides a collection of algorithms for string manipulation, including functions for removing leading or trailing whitespace, case conversion, tokenization, and search.
+
* boost:tokenizer[] provides a tokenizer class for splitting input strings into tokens based on delimiter characters or regular expressions. This can be useful for parsing and validating input data that is structured or delimited, such as CSV files, configuration files, or network protocols. The tokenizer class allows you to define custom tokenization rules and handle edge cases effectively, improving the reliability and security of input data processing.
+
* boost:property_tree[] provides a hierarchical data structure for representing and manipulating structured data, such as XML, JSON, INI, or property list formats. You can use it to parse, validate, and sanitize input data in various formats, ensuring that it conforms to expected schema or constraints before further processing.
+
* boost:regex[] provides a comprehensive regular expression library for pattern matching and text processing. Regular expressions can be powerful tools for validating and sanitizing input data, such as validating email addresses, URLs, or other structured formats.
+
* boost:spirit[] is a parsing and generation library that allows you to define parsers and generators directly within pass:[C++] code using a domain-specific embedded language (DSEL).

. *Are there Boost libraries that help with secure memory management?*
+
You can leverage various libraries to help ensure memory safety, prevent memory-related vulnerabilities, and manage resources efficiently:
+
* boost:smart_ptr[] provides smart pointer classes such as `shared_ptr`, `unique_ptr`, and `weak_ptr`, which help manage dynamic memory allocation and deallocation automatically. By using smart pointers, you can prevent common memory-related vulnerabilities such as memory leaks, dangling pointers, and double frees.
+
* boost:pool[] provides memory pool classes that allow you to efficiently allocate and deallocate fixed-size memory blocks from preallocated memory pools. Memory pools can help reduce memory fragmentation, improve memory locality, and minimize overhead associated with dynamic memory allocation.
+
* boost:interprocess[] povides classes and utilities for interprocess communication and shared memory management. This library allows multiple processes to share memory regions securely and efficiently, facilitating communication and data exchange between them, and offers features such as named shared memory, mutexes, condition variables, and allocators for managing shared memory resources robustly.
+
* boost:ptr_container[] provides container classes that manage ownership and lifetime of dynamically allocated objects stored within them. These containers, such as `ptr_vector`, `ptr_list`, and `ptr_map`, automatically delete contained objects when the container is destroyed or when objects are removed from it. By using pointer containers, you can simplify memory management and ensure proper cleanup of dynamically allocated objects, reducing the risk of memory leaks and resource exhaustion.
+
* boost:circular_buffer[] provides a circular buffer data structure that manages a fixed-size buffer with automatic wrapping behavior. Circular buffers can be used to manage memory efficiently in scenarios where a fixed-size buffer is sufficient, and memory allocation and deallocation overhead, and fragmentation, need to be minimized.

. *What penetration testing frameworks might work well with a new Boost library?*
+
While penetration testing frameworks typically focus on testing web applications, network services, and software systems, they are still useful for identifying security vulnerabilities and weaknesses in a new library, typically by developing a test application that fully engages the features of the library:
+
* https://www.metasploit.com/[Metasploit] is one of the most popular penetration testing frameworks, offering a wide range of tools and modules for exploiting vulnerabilities, conducting network reconnaissance, and assessing security posture. Metasploit modules can be customized to target specific vulnerabilities or attack vectors, such as buffer overflows, injection attacks, or memory corruption issues.
+
* https://www.zaproxy.org/[OWASP ZAP] is an open-source web application security testing tool designed for finding security vulnerabilities in web applications and APIs. Boost libraries used in web applications or services may benefit from integration with ZAP to identify vulnerabilities related to input validation, injection attacks, and other web security issues.
+
* https://nmap.org/[Nmap] (Network Mapper) is a powerful network scanning and reconnaissance tool used for discovering hosts and services on a network, identifying open ports, and detecting potential security vulnerabilities. Boost libraries used in networked applications or services may benefit from integration with Nmap to identify potential attack vectors, misconfigurations, or exposed services.
+
* https://www.tenable.com/products/nessus[NESSUS] is a widely-used vulnerability scanning tool designed for identifying security vulnerabilities, misconfigurations, and compliance violations in networked environments.
+
* https://portswigger.net/burp[Burp Suite] is a comprehensive web application security testing tool designed for finding security vulnerabilities in web applications and APIs, including input validation and injection attacks.

. *In the past, can you give me some examples of where Boost libraries have fallen short and not prevented a malicious attack?*
+
Security vulnerabilities in Boost libraries are rare compared to many other software projects, thanks to the rigorous testing, code reviews, and scrutiny they undergo. Nevertheless, there have been a few instances where security issues have been identified in Boost libraries. Here are a couple of examples:
+
* A vulnerability affected multiple versions of Boost (versions 1.61 through 1.63) and was related to the boost:filesystem[] library. The vulnerability allowed an attacker to bypass security restrictions and potentially execute arbitrary code by exploiting a symbolic link issue in the `remove_all` function. This issue was addressed in later versions of Boost, and users were advised to update their installations to mitigate the risk.
+
* Another vulnerability affected a later version of Boost (version 1.70). This vulnerability was related to the boost:asio[] library and could allow an attacker to cause a denial-of-service condition by triggering a stack overflow via a recursive function call. The issue was addressed in subsequent versions of boost:asio[], and users were encouraged to upgrade to the latest version to prevent potential exploitation.

. *If I write a library for Boost, what are the legal ramifications if there are security breaches using features of my library?*
+
As a developer contributing a library to the Boost pass:[C++] libraries, you generally retain ownership of the copyright to your code, but you also grant a license to the Boost Software License (BSL) for distribution as part of the Boost libraries. The Boost Software License is a permissive open-source license that allows users to freely use, modify, and distribute the library, subject to certain conditions.
+
The xref:user-guide:ROOT:bsl.adoc[Boost Software License] includes a disclaimer of liability clause, which limits the liability of the library author and contributors for damages arising from the use or distribution of the library. This means that as the library author, you are generally not held legally responsible for any damages or losses resulting from security breaches or vulnerabilities in your library.
+
Users of your library are responsible for their own use and deployment of the library, including ensuring the security of their applications and systems. *While you have a duty to exercise reasonable care in the development and maintenance of your library, users are ultimately responsible for assessing and mitigating any security risks associated with its usage.*
+
In the event of a security breach or vulnerability in your library, it is important to respond promptly and responsibly by disclosing the issue, providing mitigations or workarounds, and releasing updates or patches to address the vulnerability. Prompt and transparent communication with the community helps minimize the impact of security incidents and demonstrates your commitment to security and accountability.
+
Depending on the circumstances and applicable laws, there may be legal obligations to report security breaches or vulnerabilities, especially if they involve personal data or sensitive information. It's important to familiarize yourself with relevant legal requirements and best practices for handling security incidents, including data breach notification laws and industry-specific regulations. Engaging with the Boost community and collaborating with security researchers can help identify and address security vulnerabilities proactively. Encouraging responsible disclosure of security issues, providing clear channels for reporting vulnerabilities, and acknowledging contributions from security researchers fosters a culture of security awareness and helps improve the overall security posture of your library.

. *Can you recommend a book that would give me best practices for threat modelling for my Boost library?*
+
There are several books that cover threat modeling principles, techniques, and applicable best practices:
+
* _Threat Modeling: Designing for Security_ by Adam Shostack. This book includes a comprehensive introduction to threat modeling, covering fundamental concepts, methodologies, and practical techniques for identifying and mitigating security threats in software systems.
+
* _Threat Modeling: Uncover Security Design Flaws Using the STRIDE Approach_ by Frank Swiderski and Window Snyder. This book introduces the STRIDE threat modeling framework, which helps identify and analyze security threats based on six categories: Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privilege.
+
* _Threat Modeling: A Practical Guide for Development Teams_ by Mark E. Donaldson, James B. Ransome, and Andrew N. Nelson. This book offers practical guidance, real-world examples, and insights for integrating threat modeling into the software development process. It covers a range of threat modeling techniques, tools, and best practices, including data flow diagrams, attack trees, and risk analysis.
+
* _Software Security Engineering: A Guide for Project Managers_ by Julia H. Allen, Sean Barnum, and Robert J. Ellison. This book provides a comprehensive overview of software security engineering principles, practices, and processes. It covers a wide range of topics related to software security, including threat modeling, security requirements analysis, security architecture, secure coding practices, and security testing.


== Testing

. *What Boost libraries are useful examples of how to add Continuous Integration (CI) into the library testing process?*
+
The following libraries are solid examples of how Continuous Integration (CI) is integrated into the testing process:
+
* boost:asio[] is a cross-platform library for network and low-level I/O programming that relies heavily on CI systems for testing and validation. 
* boost:test[] supports unit testing in pass:[C++] and provides a framework for writing and running test cases, as well as utilities for organizing and reporting test results. boost:test[] leverages CI to ensure the correctness and reliability of its functionality across different platforms, compilers, and network configurations.
* boost:thread[], a set of classes and functions for multithreading, is tested rigorously using CI systems to verify its correctness, performance, and portability across various platforms and environments. CI helps identify threading-related issues, including feared and difficult-to-debug race conditions.
* boost:property-tree[] reads, manipulates and writes structured data. CI is used to validate the correctness and robustness of the parsing, serialization and manipulation features across diverse use cases and data sources.
* boost:filesystem[] relies on CI systems to validate its functionality across different operating systems, file systems, and compiler environments, from basic file I/O operations to more complex file management tasks.
+
By studying how these libraries implement CI into their testing processes, newcomers can gain valuable insights into best practices for ensuring the quality and reliability of their own library contributions.
+
Refer also to xref:testing/continuous-integration.adoc[].


== See Also

* xref:best-practices.adoc[]
* xref:release-process.adoc[]
* xref:version-control.adoc[]
* xref:user-guide:ROOT:faq.adoc[User Guide FAQ]

